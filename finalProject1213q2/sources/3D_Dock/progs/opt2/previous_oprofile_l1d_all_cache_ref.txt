/* 
 * Command line: opannotate --source ./ftdock 
 * 
 * Interpretation of command line:
 * Output annotated source file with samples
 * Output all files
 * 
 * CPU: Core 2, speed 3e+06 MHz (estimated)
 * Counted L1D_ALL_CACHE_REF events (L1 data cacheable reads and writes) with a unit mask of 0x02 (No unit mask) count 50000
 */
/* 
 * Total samples for file : "/home2/users/alumnes/1125822/dades/linux/PCA/ProjecteFinal/finalProject1213q2/sources/3D_Dock/progs/electrostatics.c"
 * 
 * 366808 38.8120
 */


               :/*
               :This file is part of ftdock, a program for rigid-body protein-protein docking 
               :Copyright (C) 1997-2000 Gidon Moont
               :
               :Biomolecular Modelling Laboratory
               :Imperial Cancer Research Fund
               :44 Lincoln's Inn Fields
               :London WC2A 3PX
               :
               :+44 (0)20 7269 3348
               :http://www.bmm.icnet.uk/
               :
               :This program is free software; you can redistribute it and/or
               :modify it under the terms of the GNU General Public License
               :as published by the Free Software Foundation; either version 2
               :of the License, or (at your option) any later version.
               :
               :This program is distributed in the hope that it will be useful,
               :but WITHOUT ANY WARRANTY; without even the implied warranty of
               :MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :GNU General Public License for more details.
               :
               :You should have received a copy of the GNU General Public License
               :along with this program; if not, write to the Free Software
               :Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
               :
               :*/
               :
               :#include "structures.h"
               :
               :#define PYTHAGORAS(x1, y1, z1, x2, y2, z2) sqrt( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) + ( ( z1 - z2 ) * ( z1 - z2 ) ) );
               :
               :void assign_charges( struct Structure This_Structure ) { /* assign_charges total:      1 1.1e-04 */
               :
               :/************/
               :
               :  /* Counters */
               :
               :  int	residue , atom ;
               :
               :/************/
               :
               :  for( residue = 1 ; residue <= This_Structure.length ; residue ++ ) {
               :    for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      This_Structure.Residue[residue].Atom[atom].charge = 0.0 ;
               :
               :      /* peptide backbone */
               :
     1 1.1e-04 :      if( strcmp( This_Structure.Residue[residue].Atom[atom].atom_name , " N  " ) == 0 ) {
               :        if( strcmp( This_Structure.Residue[residue].res_name , "PRO" ) == 0 ) {
               :          This_Structure.Residue[residue].Atom[atom].charge = -0.10 ;
               :        } else {
               :          This_Structure.Residue[residue].Atom[atom].charge =  0.55 ;
               :          if( residue == 1 ) This_Structure.Residue[residue].Atom[atom].charge = 1.00 ;
               :        }
               :      }
               :
               :      if( strcmp( This_Structure.Residue[residue].Atom[atom].atom_name , " O  " ) == 0 ) {
               :        This_Structure.Residue[residue].Atom[atom].charge = -0.55 ;
               :        if( residue == This_Structure.length  ) This_Structure.Residue[residue].Atom[atom].charge = -1.00 ;
               :      }
               :
               :      /* charged residues */
               :
               :      if( ( strcmp( This_Structure.Residue[residue].res_name , "ARG" ) == 0 ) && ( strncmp( This_Structure.Residue[residue].Atom[atom].atom_name , " NH" , 3 ) == 0 ) ) This_Structure.Residue[residue].Atom[atom].charge =  0.50 ;
               :      if( ( strcmp( This_Structure.Residue[residue].res_name , "ASP" ) == 0 ) && ( strncmp( This_Structure.Residue[residue].Atom[atom].atom_name , " OD" , 3 ) == 0 ) ) This_Structure.Residue[residue].Atom[atom].charge = -0.50 ;
               :      if( ( strcmp( This_Structure.Residue[residue].res_name , "GLU" ) == 0 ) && ( strncmp( This_Structure.Residue[residue].Atom[atom].atom_name , " OE" , 3 ) == 0 ) ) This_Structure.Residue[residue].Atom[atom].charge = -0.50 ;
               :      if( ( strcmp( This_Structure.Residue[residue].res_name , "LYS" ) == 0 ) && ( strcmp( This_Structure.Residue[residue].Atom[atom].atom_name , " NZ " ) == 0 ) ) This_Structure.Residue[residue].Atom[atom].charge =  1.00 ;
               :
               :    }
               :  }
               :
               :/************/
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :void electric_field( struct Structure This_Structure , float grid_span , int grid_size , fftw_real *grid ) { /* electric_field total: 366742 38.8050 */
               :
               :/************/
               :
               :  /* Counters */
               :
               :  int	residue , atom ;
               :
               :  /* Co-ordinates */
               :
               :  int	x , y , z ;
               :  float		x_centre , y_centre , z_centre ;
               :
               :  /* Variables */
               :
               :  float		distance ;
               :  float		phi , epsilon ;
               :
               :/************/
               :
               :  for( x = 0 ; x < grid_size ; x ++ ) {
               :    for( y = 0 ; y < grid_size ; y ++ ) {
               :      for( z = 0 ; z < grid_size ; z ++ ) {
               :
    17  0.0018 :        grid[gaddress(x,y,z,grid_size)] = (fftw_real)0 ;
               :
               :      }
               :    }
               :  }
               :
               :/************/
               :
               :  setvbuf( stdout , (char *)NULL , _IONBF , 0 ) ;
               :
               :  printf( "  electric field calculations ( one dot / grid sheet ) " ) ;
               :
               :  for( x = 0 ; x < grid_size ; x ++ ) {
               :
               :    printf( "." ) ;
               :
               :    x_centre  = gcentre( x , grid_span , grid_size ) ;
               :
     3 3.2e-04 :    for( y = 0 ; y < grid_size ; y ++ ) {
               :
     4 4.2e-04 :      y_centre  = gcentre( y , grid_span , grid_size ) ;
               :
   116  0.0123 :      for( z = 0 ; z < grid_size ; z ++ ) {
               :
    74  0.0078 :        z_centre  = gcentre( z , grid_span , grid_size ) ;
               :
               :        phi = 0 ;
               :
 18034  1.9082 :        for( residue = 1 ; residue <= This_Structure.length ; residue ++ ) {
 49722  5.2611 :          for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom ++ ) {
               :
 43992  4.6548 :            if( This_Structure.Residue[residue].Atom[atom].charge != 0 ) {
               :
223549 23.6537 :              distance = PYTHAGORAS( This_Structure.Residue[residue].Atom[atom].coord[1] , This_Structure.Residue[residue].Atom[atom].coord[2] , This_Structure.Residue[residue].Atom[atom].coord[3] , x_centre , y_centre , z_centre ) ;
               :         
               :              if( distance < 2.0 ) distance = 2.0 ;
               :
 30259  3.2017 :              if (distance < 8) { 
               :
    71  0.0075 :                if( distance <= 6.0 ) { 
               :
   415  0.0439 :                  epsilon = 4 ;
               :             
               :                } else {
               :
    34  0.0036 :                  epsilon = ( 38 * distance ) - 224 ;
               :
               :                }
               :  
   309  0.0327 :                phi += ( This_Structure.Residue[residue].Atom[atom].charge / ( epsilon * distance ) ) ;
               :
               :              }
               :
               :            }
               :
               :          }
               :        }
               :
   143  0.0151 :        grid[gaddress(x,y,z,grid_size)] = (fftw_real)phi ;
               :
               :      }
               :    }
               :  }
               :
               :  printf( "\n" ) ;
               :
               :/************/
               :
               :  return ;
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :void electric_point_charge( struct Structure This_Structure , float grid_span , int grid_size , fftw_real *grid ) { /* electric_point_charge total:     14  0.0015 */
               :
               :/************/
               :
               :  /* Counters */
               :
               :  int	residue , atom ;
               :
               :  /* Co-ordinates */
               :
               :  int	x , y , z ;
               :  int	x_low , x_high , y_low , y_high , z_low , z_high ;
               :
               :  float		a , b , c ;
               :  float		x_corner , y_corner , z_corner ;
               :  float		w ;
               :
               :  /* Variables */
               :
               :  float		one_span ;
               :
               :/************/
               :
               :  for( x = 0 ; x < grid_size ; x ++ ) {
               :    for( y = 0 ; y < grid_size ; y ++ ) {
     1 1.1e-04 :      for( z = 0 ; z < grid_size ; z ++ ) {
               :
    13  0.0014 :        grid[gaddress(x,y,z,grid_size)] = (fftw_real)0 ;
               :
               :      }
               :    }
               :  }
               :
               :/************/
               :
               :  one_span = grid_span / (float)grid_size ;
               :
               :  for( residue = 1 ; residue <= This_Structure.length ; residue ++ ) {
               :    for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      if( This_Structure.Residue[residue].Atom[atom].charge != 0 ) {
               :
               :        x_low = gord( This_Structure.Residue[residue].Atom[atom].coord[1] - ( one_span / 2 ) , grid_span , grid_size ) ;
               :        y_low = gord( This_Structure.Residue[residue].Atom[atom].coord[2] - ( one_span / 2 ) , grid_span , grid_size ) ;
               :        z_low = gord( This_Structure.Residue[residue].Atom[atom].coord[3] - ( one_span / 2 ) , grid_span , grid_size ) ;
               :
               :        x_high = x_low + 1 ;
               :        y_high = y_low + 1 ;
               :        z_high = z_low + 1 ;
               :
               :        a = This_Structure.Residue[residue].Atom[atom].coord[1] - gcentre( x_low , grid_span , grid_size ) - ( one_span / 2 ) ;
               :        b = This_Structure.Residue[residue].Atom[atom].coord[2] - gcentre( y_low , grid_span , grid_size ) - ( one_span / 2 ) ;
               :        c = This_Structure.Residue[residue].Atom[atom].coord[3] - gcentre( z_low , grid_span , grid_size ) - ( one_span / 2 ) ;
               :
               :        for( x = x_low ; x <= x_high  ; x ++ ) {
               : 
               :          x_corner = one_span * ( (float)( x - x_high ) + .5 ) ;
               :
               :          for( y = y_low ; y <= y_high  ; y ++ ) {
               :
               :            y_corner = one_span * ( (float)( y - y_high ) + .5 ) ;
               :
               :            for( z = z_low ; z <= z_high  ; z ++ ) {
               :
               :              z_corner = one_span * ( (float)( z - z_high ) + .5 ) ;
               :
               :              w = ( ( x_corner + a ) * ( y_corner + b ) * ( z_corner + c ) ) / ( 8.0 * x_corner * y_corner * z_corner ) ;
               :
               :              grid[gaddress(x,y,z,grid_size)] += (fftw_real)( w * This_Structure.Residue[residue].Atom[atom].charge ) ;
               :
               :            }
               :          }
               :        }
               :
               :      }
               :
               :    }
               :  }
               :
               :/************/
               :
               :  return ;
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :void electric_field_zero_core( int grid_size , fftw_real *elec_grid , fftw_real *surface_grid , float internal_value ) { /* electric_field_zero_core total:     51  0.0054 */
               :
               :/************/
               :
               :  /* Co-ordinates */
               :
               :  int	x , y , z ;
               :
               :/************/
               :
               :  for( x = 0 ; x < grid_size ; x ++ ) {
               :    for( y = 0 ; y < grid_size ; y ++ ) {
    42  0.0044 :      for( z = 0 ; z < grid_size ; z ++ ) {
               :
     9 9.5e-04 :        if( surface_grid[gaddress(x,y,z,grid_size)] == (fftw_real)internal_value ) elec_grid[gaddress(x,y,z,grid_size)] = (fftw_real)0 ;
               :
               :      }
               :    }
               :  }
               :
               :/************/
               :
               :  return ;
               :
               :}
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/gcc-4.6.2-20111026/obj-i586-suse-linux/i586-suse-linux/libgcc/../../../libgcc/../gcc/libgcc2.c"
 * 
 *  35255  3.7303
 */


 /* __moddi3 total:  35255  3.7303 */
/* 
 * Total samples for file : "executor.c"
 * 
 *  11441  1.2106
 */

<credited to line zero>  11441  1.2106 :
 /* executor_many total:  11441  1.2106 */
/* 
 * Total samples for file : "planner.c"
 * 
 *   8516  0.9011
 */

<credited to line zero>   8516  0.9011 :
 /* fftw_measure_runtime.constprop.6 total:   8516  0.9011 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/malloc/malloc.c"
 * 
 *   5535  0.5857
 */


 /* malloc total:    742  0.0785 */
 /* free total:    141  0.0149 */
 /* realloc total:      1 1.1e-04 */
 /* _int_malloc total:   3131  0.3313 */
 /* _int_free total:   1519  0.1607 */
 /* _int_realloc total:      1 1.1e-04 */
/* 
 * Total samples for file : "rexec.c"
 * 
 *   3869  0.4094
 */

<credited to line zero>   3869  0.4094 :
 /* rexecutor_many total:   3869  0.4094 */
/* 
 * Total samples for file : "/home2/users/alumnes/1125822/dades/linux/PCA/ProjecteFinal/finalProject1213q2/sources/3D_Dock/progs/grid.c"
 * 
 *   3482  0.3684
 */


               :/*
               :This file is part of ftdock, a program for rigid-body protein-protein docking 
               :Copyright (C) 1997-2000 Gidon Moont
               :
               :Biomolecular Modelling Laboratory
               :Imperial Cancer Research Fund
               :44 Lincoln's Inn Fields
               :London WC2A 3PX
               :
               :+44 (0)20 7269 3348
               :http://www.bmm.icnet.uk/
               :
               :This program is free software; you can redistribute it and/or
               :modify it under the terms of the GNU General Public License
               :as published by the Free Software Foundation; either version 2
               :of the License, or (at your option) any later version.
               :
               :This program is distributed in the hope that it will be useful,
               :but WITHOUT ANY WARRANTY; without even the implied warranty of
               :MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :GNU General Public License for more details.
               :
               :You should have received a copy of the GNU General Public License
               :along with this program; if not, write to the Free Software
               :Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
               :
               :*/
               :
               :#include "structures.h"
               :
     4 4.2e-04 :void discretise_structure( struct Structure This_Structure , float grid_span , int grid_size , fftw_real *grid ) { /* discretise_structure total:    541  0.0572 */
               :
               :/************/
               :
               :  /* Counters */
               :
               :  int	residue , atom ;
               :
               :  /* Co-ordinates */
               :
               :  int	x , y , z ;
               :  int	steps , x_step , y_step , z_step ;
               :
               :  float		x_centre , y_centre , z_centre ;
               :
               :  /* Variables */
               :
               :  float         distance , one_span ;
               :
               :/************/
               :
               :  one_span = grid_span / (float)grid_size ;
               :
               :  distance = 1.8 ;
               :
               :/************/
               :
               :  for( x = 0 ; x < grid_size ; x ++ ) {
     3 3.2e-04 :    for( y = 0 ; y < grid_size ; y ++ ) {
     2 2.1e-04 :      for( z = 0 ; z < grid_size ; z ++ ) {
               :
    22  0.0023 :        grid[gaddress(x,y,z,grid_size)] = (fftw_real)0 ;
               :
               :      }
               :    }
               :  }
               :
               :/************/
               :
               :  steps = (int)( ( distance / one_span ) + 1.5 ) ;
               :
               :  for( residue = 1 ; residue <= This_Structure.length ; residue ++ ) {
               :    for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      x = gord( This_Structure.Residue[residue].Atom[atom].coord[1] , grid_span , grid_size ) ;
               :      y = gord( This_Structure.Residue[residue].Atom[atom].coord[2] , grid_span , grid_size ) ;
               :      z = gord( This_Structure.Residue[residue].Atom[atom].coord[3] , grid_span , grid_size ) ;
               :
     2 2.1e-04 :      for( x_step = max( ( x - steps ) , 0 ) ; x_step <= min( ( x + steps ) , ( grid_size - 1 ) ) ; x_step ++ ) {
               :
     5 5.3e-04 :        x_centre  = gcentre( x_step , grid_span , grid_size ) ;
               :
    11  0.0012 :        for( y_step = max( ( y - steps ) , 0 ) ; y_step <= min( ( y + steps ) , ( grid_size - 1 ) ) ; y_step ++ ) {
               :
    38  0.0040 :          y_centre  = gcentre( y_step , grid_span , grid_size ) ;
               :
    15  0.0016 :          for( z_step = max( ( z - steps ) , 0 ) ; z_step <= min( ( z + steps ) , ( grid_size - 1 ) ) ; z_step ++ ) {
               :
   219  0.0232 :            z_centre  = gcentre( z_step , grid_span , grid_size ) ;
               :
   220  0.0233 :            if( pythagoras( This_Structure.Residue[residue].Atom[atom].coord[1] , This_Structure.Residue[residue].Atom[atom].coord[2] , This_Structure.Residue[residue].Atom[atom].coord[3] , x_centre , y_centre , z_centre ) < distance ) grid[gaddress(x_step,y_step,z_step,grid_size)] = (fftw_real)1 ;
               :
               :          }
               :        }
               :      }
               :
               :    }
               :  }
               :
               :/************/
               :
               :  return ;
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
   363  0.0384 :void surface_grid( float grid_span , int grid_size , fftw_real *grid , float surface , float internal_value ) { /* surface_grid total:   2941  0.3112 */
               :
               :
               :/************/
               :
               :  /* Counters */
               :
               :  int	x , y , z ;
               :  int	steps , x_step , y_step , z_step ;
               :
               :  /* Variables */
               :
               :  float		one_span ;
               :
               :  int	at_surface ;
               :
               :/************/
               :
               :  one_span = grid_span / (float)grid_size ;
               :
               :/************/
               :
               :  /* Surface grid atoms */
               :
               :  steps = (int)( ( surface / one_span ) + 1.5 ) ;
               :
               :  for( x = 0 ; x < grid_size ; x ++ ) {
     1 1.1e-04 :    for( y = 0 ; y < grid_size ; y ++ ) {
   106  0.0112 :      for( z = 0 ; z < grid_size ; z ++ ) {
               :
   280  0.0296 :        if( (int)grid[gaddress(x,y,z,grid_size)] == 1 ) {
               :
               :          at_surface = 0 ;
               :
    22  0.0023 :          for( x_step = max( x - steps , 0 ) ; x_step <= min( x + steps , grid_size - 1 ) ; x_step ++ ) {
   185  0.0196 :            for( y_step = max( y - steps , 0 ) ; y_step <= min( y + steps , grid_size - 1 ) ; y_step ++ ) {
   697  0.0737 :              for( z_step = max( z - steps , 0 ) ; z_step <= min( z + steps , grid_size - 1 ) ; z_step ++ ) {
               :
   686  0.0726 :                if( (int)grid[gaddress(x_step,y_step,z_step,grid_size)] == 0 ) {
               :
   599  0.0634 :                  if( ( (float)( ( ( x_step - x ) * ( x_step - x ) ) + ( ( y_step - y ) * ( y_step - y ) ) + ( ( z_step - z ) * ( z_step - z ) ) ) * one_span * one_span ) < ( surface * surface ) ) at_surface = 1 ;
               :
               :                }
               :
               :              }
               :            }
               :          }
               :
     2 2.1e-04 :          if( at_surface == 0 ) grid[gaddress(x,y,z,grid_size)] = (fftw_real)internal_value ;
               :
               :        }
               :
               :      }
               :    }
               :  }
               :
               :/************/
               :
               :  return ;
               :
               :}
/* 
 * Total samples for file : "rplanner.c"
 * 
 *   3171  0.3355
 */

<credited to line zero>   3171  0.3355 :
 /* rfftw_measure_runtime.constprop.6 total:   3171  0.3355 */
/* 
 * Total samples for file : "/home2/users/alumnes/1125822/dades/linux/PCA/ProjecteFinal/finalProject1213q2/sources/3D_Dock/progs/ftdock.c"
 * 
 *   1452  0.1536
 */


               :/*
               :This file is part of ftdock, a program for rigid-body protein-protein docking 
               :Copyright (C) 1997-2000 Gidon Moont
               :
               :Biomolecular Modelling Laboratory
               :Imperial Cancer Research Fund
               :44 Lincoln's Inn Fields
               :London WC2A 3PX
               :
               :+44 (0)20 7269 3348
               :http://www.bmm.icnet.uk/
               :
               :This program is free software; you can redistribute it and/or
               :modify it under the terms of the GNU General Public License
               :as published by the Free Software Foundation; either version 2
               :of the License, or (at your option) any later version.
               :
               :This program is distributed in the hope that it will be useful,
               :but WITHOUT ANY WARRANTY; without even the implied warranty of
               :MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :GNU General Public License for more details.
               :
               :You should have received a copy of the GNU General Public License
               :along with this program; if not, write to the Free Software
               :Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
               :
               :*/
               :
               :#include "structures.h"
               :#include <sys/time.h>
               :#include <sys/resource.h>
               :
               :
               :void print_electric_grid ( fftw_real *grid, int grid_size)
               :{
               :  int i, diff;
               :
               :  for (i=0; i<(grid_size * grid_size * ( 2 * ( grid_size / 2 + 1 ) ) * sizeof( fftw_real ))-3; i+=4) 
               :       write (1, (void *)((char *)grid+i), sizeof(int));  
               :  if ((diff=i-(grid_size * grid_size * ( 2 * ( grid_size / 2 + 1 ) ) * sizeof( fftw_real )))>0)
               :       write(1,(void *)((char *)grid+i),diff);
               :
               :}
               :
    73  0.0077 :int main( int argc , char *argv[] ) { /* main total:   1452  0.1536 */
               :
               :  /* index counters */
               :
               :  int	i ;
               :
               :  /* Command line options */
               :
               :  char		*output_file_name ;
               :  char		*static_file_name ;
               :  char		*mobile_file_name ;
               :  int		global_grid_size ;
               :  int		angle_step ;
               :  float		surface ;
               :  float		internal_value ;
               :  int		electrostatics ;
               :  int		keep_per_rotation ;
               :  int 		kept_scores ;
               :  int		rescue ;
               :  int		calculate ;
               :  float		reverse_calculated_one_span ;
               :
               :  char		*default_global_grid_size ;
               :  char		*default_angle_step ;
               :  char		*default_surface ;
               :  char		*default_internal_value ;
               :  char		*default_electrostatics ;
               :  char		*default_keep_per_rotation ;
               :
               :  /* File stuff */
               :
               :  FILE		*ftdock_file ;
               :  char		line_buffer[100] ;
               :  int		id , id2 , SCscore ;
               :  float		RPscore ;
               :  int		x , y , z , z_twist , theta , phi ;
               :
               :  /* Angles stuff */
               :
               :  struct Angle	Angles ;
               :  int		first_rotation , rotation ;
               :
               :  /* Structures */
               :
               :  struct Structure	Static_Structure , Mobile_Structure ;
               :  struct Structure	Origin_Static_Structure , Origin_Mobile_Structure ;
               :  struct Structure	Rotated_at_Origin_Mobile_Structure ;
               :
               :  /* Co-ordinates */
               :
               :  int		xyz , fx , fy , fz , fxyz ;
               :
               :  /* Grid stuff */
               :
               :  float		grid_span , one_span ;
               :
               :  fftw_real	*static_grid ;
               :  fftw_real	*mobile_grid ;
               :  fftw_real	*convoluted_grid ;
               :
               :  fftw_real	*static_elec_grid = ( void * ) 0 ;
               :  fftw_real	*mobile_elec_grid = ( void * ) 0 ;
               :  fftw_real	*convoluted_elec_grid = ( void * ) 0 ;
               :
               :  /* FFTW stuff */
               :
               :  rfftwnd_plan	p , pinv ;
               :
               :  fftw_complex  *static_fsg ;
               :  fftw_complex  *mobile_fsg ;
               :  fftw_complex  *multiple_fsg ;
               :
               :  fftw_complex  *static_elec_fsg = ( void * ) 0 ;
               :  fftw_complex  *mobile_elec_fsg = ( void * ) 0 ;
               :  fftw_complex  *multiple_elec_fsg = ( void * ) 0 ;
               :
               :  /* Scores */
               :
               :  struct Score	*Scores ;
               :  float		max_es_value ;
               :
               :/************/
               :
               :  /* Its nice to tell people what going on straight away */
               :
               :  setvbuf( stdout , (char *)NULL , _IONBF , 0 ) ;
               :
               :
               :  printf( "\n          3D-Dock Suite (March 2001)\n" ) ;
               :  printf( "          Copyright (C) 1997-2000 Gidon Moont\n" ) ;
               :  printf( "          This program comes with ABSOLUTELY NO WARRANTY\n" ) ;
               :  printf( "          for details see license. This program is free software,\n"); 
               :  printf( "          and you may redistribute it under certain conditions.\n\n"); 
               :
               :  printf( "          Biomolecular Modelling Laboratory\n" ) ;
               :  printf( "          Imperial Cancer Research Fund\n" ) ;
               :  printf( "          44 Lincoln's Inn Fields\n" ) ;
               :  printf( "          London WC2A 3PX\n" ) ;
               :  printf( "          +44 (0)20 7269 3348\n" ) ;
               :  printf( "          http://www.bmm.icnet.uk/\n\n" ) ;
               :
               :
               :  printf( "Starting FTDock (v2.0) global search program\n" ) ;
               :
               :
               :/************/
               :
               :  /* Memory allocation */
               :
               :  if( ( ( output_file_name  = ( char * ) malloc ( 500 * sizeof( char ) ) ) == NULL ) ||
               :      ( ( static_file_name  = ( char * ) malloc ( 500 * sizeof( char ) ) ) == NULL ) ||
               :      ( ( mobile_file_name  = ( char * ) malloc ( 500 * sizeof( char ) ) ) == NULL ) ) {
               :    GENERAL_MEMORY_PROBLEM 
               :  }
               :
               :/************/
               :
               :  /* Command Line defaults */
               :
               :  strcpy( output_file_name , "ftdock_global.dat" ) ;
               :  strcpy( static_file_name , " --static file name was not provided--" ) ;
               :  strcpy( mobile_file_name , " --mobile file name was not provided--" ) ;
               :  global_grid_size = 128 ;
               :  angle_step = 12 ;
               :  surface = 1.3 ;
               :  internal_value = -15 ;
               :  electrostatics = 1 ;
               :  keep_per_rotation = 3 ;
               :  rescue = 0 ;
               :  calculate = 1 ;
               :  reverse_calculated_one_span = 0.7 ;
               :
               :  default_global_grid_size = "(default calculated)" ;
               :  default_angle_step = "(default)" ;
               :  default_surface = "(default)" ;
               :  default_internal_value = "(default)" ;
               :  default_electrostatics = "(default)" ;
               :  default_keep_per_rotation = "(default)" ;
               :
               :  /* Command Line parse */
               :
               :  for( i = 1 ; i < argc ; i ++ ) {
               :
               :    if( strcmp( argv[i] , "-out" ) == 0 ) {
               :      i ++ ;
               :      if( ( i == argc ) || ( strncmp( argv[i] , "-" , 1 ) == 0 ) ) {
               :        printf( "Bad command line\n" ) ;
               :        exit( EXIT_FAILURE ) ;
               :      }
               :      strcpy( output_file_name , argv[i] ) ;
               :    } else {
               :      if( strcmp( argv[i] , "-static" ) == 0 ) {
               :        i ++ ;
               :        if( ( i == argc ) || ( strncmp( argv[i] , "-" , 1 ) == 0 ) ) {
               :          printf( "Bad command line\n" ) ;
               :          exit( EXIT_FAILURE ) ;
               :        }
               :        strcpy( static_file_name , argv[i] ) ;
               :      } else {
               :        if( strcmp( argv[i] , "-mobile" ) == 0 ) {
               :          i ++ ;
               :          if( ( i == argc ) || ( strncmp( argv[i] , "-" , 1 ) == 0 ) ) {
               :            printf( "Bad command line\n" ) ;
               :            exit( EXIT_FAILURE ) ;
               :          }
               :          strcpy( mobile_file_name , argv[i] ) ;
               :        } else {
               :          if( strcmp( argv[i] , "-grid" ) == 0 ) {
               :            i ++ ;
               :            if( ( i == argc ) || ( strncmp( argv[i] , "-" , 1 ) == 0 ) ) {
               :              printf( "Bad command line\n" ) ;
               :              exit( EXIT_FAILURE ) ;
               :            }
               :            sscanf( argv[i] , "%d" , &global_grid_size ) ;
               :            if( ( global_grid_size % 2 ) != 0 ) {
               :              printf( "Grid size must be even\n" ) ;
               :              exit( EXIT_FAILURE ) ;
               :            }
               :            default_global_grid_size = "(user defined)" ;
               :            calculate = 0 ;
               :          } else {
               :            if( strcmp( argv[i] , "-angle_step" ) == 0 ) {
               :              i ++ ;
               :              if( ( i == argc ) || ( strncmp( argv[i] , "-" , 1 ) == 0 ) ) {
               :                printf( "Bad command line\n" ) ;
               :                exit( EXIT_FAILURE ) ;
               :              }
               :              sscanf( argv[i] , "%d" , &angle_step ) ;
               :              default_angle_step = "(user defined)" ;
               :            } else {
               :              if( strcmp( argv[i] , "-surface" ) == 0 ) {
               :                i ++ ;
               :                if( ( i == argc ) || ( strncmp( argv[i] , "-" , 1 ) == 0 ) ) {
               :                  printf( "Bad command line\n" ) ;
               :                  exit( EXIT_FAILURE ) ;
               :                }
               :                sscanf( argv[i] , "%f" , &surface ) ;
               :                default_surface = "(user defined)" ;
               :              } else {
               :                if( strcmp( argv[i] , "-internal" ) == 0 ) {
               :                  i ++ ;
               :                  if( i == argc ) {
               :                    printf( "Bad command line\n" ) ;
               :                    exit( EXIT_FAILURE ) ;
               :                  }
               :                  sscanf( argv[i] , "%f" , &internal_value ) ;
               :                  default_internal_value = "(user defined)" ;
               :                } else {
               :                  if( strcmp( argv[i] , "-noelec" ) == 0 ) {
               :                    electrostatics = 0 ;
               :                    default_electrostatics = "(user defined)" ;
               :                  } else {
               :                    if( strcmp( argv[i] , "-keep" ) == 0 ) {
               :                      i ++ ;
               :                      if( ( i == argc ) || ( strncmp( argv[i] , "-" , 1 ) == 0 ) ) {
               :                        printf( "Bad command line\n" ) ;
               :                        exit( EXIT_FAILURE ) ;
               :                      }
               :                      sscanf( argv[i] , "%d" , &keep_per_rotation ) ;
               :                      default_keep_per_rotation = "(user defined)" ;
               :                    } else {
               :                      if( strcmp( argv[i] , "-rescue" ) == 0 ) {
               :                        rescue = 1 ;
               :                      } else {
               :                        if( strcmp( argv[i] , "-calculate_grid" ) == 0 ) {
               :                          i ++ ;
               :                          if( ( i == argc ) || ( strncmp( argv[i] , "-" , 1 ) == 0 ) ) {
               :                            printf( "Bad command line\n" ) ;
               :                            exit( EXIT_FAILURE ) ;
               :                          }
               :                          calculate = 1 ;
               :                          default_global_grid_size = "(user defined calculated)" ;
               :                          sscanf( argv[i] , "%f" , &reverse_calculated_one_span ) ;
               :                        } else {
               :                          printf( "Bad command line\n" ) ;
               :                          exit( EXIT_FAILURE ) ;
               :                        }
               :                      }
               :                    }
               :                  }
               :                }
               :              }
               :            }
               :          }
               :        }
               :      }
               :    }
               :
               :  }
               :
               :/************/
               :
               :  /* Rescue option */
               :
               :  if( rescue == 1 ) {
               :
               :    printf( "RESCUE mode\n" ) ;
               :
               :    if( ( ftdock_file = fopen( "scratch_parameters.dat" , "r" ) ) == NULL ) {
               :      printf( "Could not open scratch_parameters.dat for reading.\nDying\n\n" ) ;
               :      exit( EXIT_FAILURE ) ;
               :    }
               :
               :    calculate = 0 ;
               :
               :    default_global_grid_size = "(read from rescue file)" ;
               :    default_angle_step = "(read from rescue file)" ;
               :    default_surface = "(read from rescue file)" ;
               :    default_internal_value = "(read from rescue file)" ;
               :    default_electrostatics = "(read from rescue file)" ;
               :
               :    while( fgets( line_buffer , 99 , ftdock_file ) ) {
               :
               :      if( strncmp( line_buffer , "Static molecule" , 15 ) == 0 ) sscanf( line_buffer , "Static molecule :: %s" , static_file_name ) ;
               :      if( strncmp( line_buffer , "Mobile molecule" , 15 ) == 0 ) sscanf( line_buffer , "Mobile molecule :: %s" , mobile_file_name ) ;
               :      if( strncmp( line_buffer , "Output file name" , 16 ) == 0 ) sscanf( line_buffer , "Output file name :: %s" , output_file_name ) ;
               :      if( strncmp( line_buffer , "Global grid size" , 16 ) == 0 ) sscanf( line_buffer , "Global grid size :: %d" , &global_grid_size ) ;
               :      if( strncmp( line_buffer , "Global search angle step" , 24 ) == 0 ) sscanf( line_buffer , "Global search angle step :: %d" , &angle_step ) ;
               :      if( strncmp( line_buffer , "Global surface thickness" , 24 ) == 0 ) sscanf( line_buffer , "Global surface thickness :: %f" , &surface ) ;
               :      if( strncmp( line_buffer , "Global internal deterrent value" , 31 ) == 0 ) sscanf( line_buffer , "Global internal deterrent value :: %f" , &internal_value ) ;
               :      if( strncmp( line_buffer , "Electrostatics                     ::     on" , 44 ) == 0 ) electrostatics = 1 ;    
               :      if( strncmp( line_buffer , "Electrostatics                     ::    off" , 44 ) == 0 ) electrostatics = 0 ;    
               :      if( strncmp( line_buffer , "Global keep per rotation" , 25 ) == 0 ) sscanf( line_buffer , "Global keep per rotation :: %d" , &keep_per_rotation ) ;
               :
               :    }
               :
               :    fclose( ftdock_file ) ;
               :
               :    if( ( ftdock_file = fopen( "scratch_scores.dat" , "r" ) ) == NULL ) {
               :      printf( "Could not open scratch_scores.dat for reading.\nDying\n\n" ) ;
               :      exit( EXIT_FAILURE ) ;
               :    }
               :
               :    fgets( line_buffer , 99 , ftdock_file ) ;
               :
               :    while( fgets( line_buffer , 99 , ftdock_file ) ) {
               :
               :      sscanf( line_buffer , "G_DATA %d " , &first_rotation ) ;
               :
               :    }
               :
               :    fclose( ftdock_file ) ;
               :
               :    first_rotation ++ ;
               :
               :    printf( "Will be starting from rotation %d\n" , first_rotation ) ;
               :
               :/************/
               :
               :  } else {
               :
               :    first_rotation = 1 ;
               :
               :  }
               :  printf( "PCA TIMING SHOULD start here\n");
               :
               :  struct rusage usage;
               :  struct timeval start_utime, end_utime, start_stime, end_stime;
               :    
               :  if (getrusage(RUSAGE_SELF, &usage) == -1) exit(0);
               :  start_utime = usage.ru_utime;
               :  start_stime = usage.ru_stime;
               :
               :/************/
               :
               :  /* Do these things first so that bad inputs will be caught soonest */
               :
               :  /* Read in Structures from pdb files */
               :  Static_Structure = read_pdb_to_structure( static_file_name ) ;
               :  Mobile_Structure = read_pdb_to_structure( mobile_file_name ) ;
               :
               :  if( Mobile_Structure.length > Static_Structure.length ) {
               :    printf( "WARNING\n" ) ;
               :    printf( "The mobile molecule has more residues than the static\n" ) ;
               :    printf( "Are you sure you have the correct molecules?\n" ) ;
               :    printf( "Continuing anyway\n" ) ;
               :  }
               :  
               :/************/
               :
               :  /* Get angles */
               :  Angles = generate_global_angles( angle_step ) ;
               :
               :  printf( "Total number of rotations is %d\n" , Angles.n ) ;
               :
               :/************/
               :
               :  /* Assign charges */
               :
               :  if( electrostatics == 1 ) {
               :    printf( "Assigning charges\n" ) ;
               :    assign_charges( Static_Structure ) ;
               :    assign_charges( Mobile_Structure ) ;
               :  }
               :
               :/************/
               :
               :  /* Store new structures centered on Origin */
               :
               :  Origin_Static_Structure = translate_structure_onto_origin( Static_Structure ) ;
               :  Origin_Mobile_Structure = translate_structure_onto_origin( Mobile_Structure ) ;
               :
               :  /* Free some memory */
               :
               :  for( i = 1 ; i <= Static_Structure.length ; i ++ ) {
               :    free( Static_Structure.Residue[i].Atom ) ;
               :  }
               :  free( Static_Structure.Residue ) ;
               :
               :  for( i = 1 ; i <= Mobile_Structure.length ; i ++ ) {
               :    free( Mobile_Structure.Residue[i].Atom ) ;
               :  }
               :  free( Mobile_Structure.Residue ) ;
               :
               :/************/
               :
               :  /* Calculate Grid stuff */
               :
               :  grid_span = total_span_of_structures( Origin_Static_Structure , Origin_Mobile_Structure ) ;
               :
               :  if( calculate == 1 ) {
               :    printf( "Using automatic calculation for grid size\n" ) ;
               :    global_grid_size = (int)( grid_span / reverse_calculated_one_span ) ;
               :    if( ( global_grid_size % 2 ) != 0 ) global_grid_size ++ ;
               :  }
               :
               :  one_span = grid_span / (float)global_grid_size ;
               :
               :  printf( "Span = %.3f angstroms\n" , grid_span ) ;
               :  printf( "Grid size = %d\n" , global_grid_size ) ;
               :  printf( "Each Grid cube = %.5f angstroms\n" , one_span ) ;
               :
               :/************/
               :
               :  /* Memory Allocation */
               :
               :  if( ( Scores = ( struct Score * ) malloc ( ( keep_per_rotation + 2 ) * sizeof( struct Score ) ) ) == NULL ) {
               :    GENERAL_MEMORY_PROBLEM
               :  }
               :
               :  if(
               :    ( ( static_grid = ( fftw_real * ) malloc
               :     ( global_grid_size * global_grid_size * ( 2 * ( global_grid_size / 2 + 1 ) ) * sizeof( fftw_real ) ) ) == NULL )
               :    ||
               :    ( ( mobile_grid = ( fftw_real * ) malloc
               :     ( global_grid_size * global_grid_size * ( 2 * ( global_grid_size / 2 + 1 ) ) * sizeof( fftw_real ) ) ) == NULL )
               :    ||
               :    ( ( convoluted_grid = ( fftw_real * ) malloc
               :     ( global_grid_size * global_grid_size * ( 2 * ( global_grid_size / 2 + 1 ) ) * sizeof( fftw_real ) ) ) == NULL )
               :    ) {
               :    printf( "Not enough memory for surface grids\nUse (sensible) smaller grid size\nDying\n\n" ) ;
               :    exit( EXIT_FAILURE ) ;
               :  }
               :
               :  static_fsg = ( fftw_complex * ) static_grid ;
               :  mobile_fsg = ( fftw_complex * ) mobile_grid ;
               :  multiple_fsg = ( fftw_complex * ) convoluted_grid ;
               :
               :  if( electrostatics == 1 ) {
               :
               :    if(
               :      ( ( static_elec_grid = ( fftw_real * ) malloc
               :       ( global_grid_size * global_grid_size * ( 2 * ( global_grid_size / 2 + 1 ) ) * sizeof( fftw_real ) ) ) == NULL )
               :      ||
               :      ( ( mobile_elec_grid = ( fftw_real * ) malloc
               :       ( global_grid_size * global_grid_size * ( 2 * ( global_grid_size / 2 + 1 ) ) * sizeof( fftw_real ) ) ) == NULL )
               :      ||
               :      ( ( convoluted_elec_grid = ( fftw_real * ) malloc
               :       ( global_grid_size * global_grid_size * ( 2 * ( global_grid_size / 2 + 1 ) ) * sizeof( fftw_real ) ) ) == NULL )
               :      ) {
               :      printf( "Not enough memory for electrostatic grids\nSwitch off electrostatics or use (sensible) smaller grid size\nDying\n\n" ) ;
               :      exit( EXIT_FAILURE ) ;
               :    } else {
               :      /* all ok */
               :      printf( "Electrostatics are on\n" ) ;
               :    }
               :
               :    static_elec_fsg = ( fftw_complex * ) static_elec_grid ;
               :    mobile_elec_fsg = ( fftw_complex * ) mobile_elec_grid ;
               :    multiple_elec_fsg = ( fftw_complex * ) convoluted_elec_grid ;
               :
               :  }
               :
               :/************/
               :
               :  /* Create FFTW plans */
               :
               :  printf( "Creating plans\n" ) ;
               :  p    = rfftw3d_create_plan( global_grid_size , global_grid_size , global_grid_size ,
               :                               FFTW_REAL_TO_COMPLEX , FFTW_MEASURE | FFTW_IN_PLACE ) ;
               :  pinv = rfftw3d_create_plan( global_grid_size , global_grid_size , global_grid_size ,
               :                               FFTW_COMPLEX_TO_REAL , FFTW_MEASURE | FFTW_IN_PLACE ) ;
               :
               :/************/
               :
               :  printf( "Setting up Static Structure\n" ) ;
               :
               :  /* Discretise and surface the Static Structure (need do only once) */
               :  discretise_structure( Origin_Static_Structure , grid_span , global_grid_size , static_grid ) ;
               :  printf( "  surfacing grid\n" ) ;
               :  surface_grid( grid_span , global_grid_size , static_grid , surface , internal_value ) ;
               :
               :  /* Calculate electic field at all grid nodes (need do only once) */
               :  if( electrostatics == 1 ) {
               :    electric_field( Origin_Static_Structure , grid_span , global_grid_size , static_elec_grid ) ;
               :    electric_field_zero_core( global_grid_size , static_elec_grid , static_grid , internal_value ) ;
               :  }
               :
               :  /* Fourier Transform the static grids (need do only once) */
               :  printf( "  one time forward FFT calculations\n" ) ;
               :  rfftwnd_one_real_to_complex( p , static_grid , NULL ) ;
               :  if( electrostatics == 1 ) {
               :    rfftwnd_one_real_to_complex( p , static_elec_grid , NULL ) ;
               :  }
               :
               :  printf( "  done\n" ) ;
               :
               :/************/
               :
               :  /* Store paramaters in case of rescue */
               :
               :  if( ( ftdock_file = fopen( "scratch_parameters.dat" , "w" ) ) == NULL ) {
               :    printf( "Could not open scratch_parameters.dat for writing.\nDying\n\n" ) ;
               :    exit( EXIT_FAILURE ) ;
               :  }
               :
               :  fprintf( ftdock_file, "\nGlobal Scan\n" ) ;
               :
               :  fprintf( ftdock_file, "\nCommand line controllable values\n" ) ;
               :  fprintf( ftdock_file, "Static molecule                    :: %s\n" , static_file_name ) ;
               :  fprintf( ftdock_file, "Mobile molecule                    :: %s\n" , mobile_file_name ) ;
               :  fprintf( ftdock_file, "Output file name                   :: %s\n" , output_file_name ) ;
               :  fprintf( ftdock_file, "\n" ) ;
               :  fprintf( ftdock_file, "Global grid size                   :: %6d      %s\n" , global_grid_size , default_global_grid_size ) ;
               :  fprintf( ftdock_file, "Global search angle step           :: %6d      %s\n" , angle_step , default_angle_step ) ;
               :  fprintf( ftdock_file, "Global surface thickness           :: %9.2f   %s\n" , surface , default_surface ) ;
               :  fprintf( ftdock_file, "Global internal deterrent value    :: %9.2f   %s\n" , internal_value , default_internal_value ) ;
               :  if( electrostatics == 1 ) {
               :    fprintf( ftdock_file, "Electrostatics                     ::     on      %s\n" , default_electrostatics ) ;
               :  } else {
               :    fprintf( ftdock_file, "Electrostatics                     ::    off      %s\n" , default_electrostatics ) ;
               :  }
               :  fprintf( ftdock_file, "Global keep per rotation           :: %6d      %s\n" , keep_per_rotation , default_keep_per_rotation ) ;
               :
               :  fprintf( ftdock_file, "\nCalculated values\n" ) ;
               :  fprintf( ftdock_file, "Global rotations                   :: %6d\n" , Angles.n ) ;
               :  fprintf( ftdock_file, "Global total span (angstroms)      :: %10.3f\n" , grid_span ) ;
               :  fprintf( ftdock_file, "Global grid cell span (angstroms)  :: %10.3f\n" , one_span ) ;
               :
               :  fclose( ftdock_file ) ;
               :
               :/************/
               :
               :  /* Main program loop */
               :
               :  max_es_value = 0 ;
               :
               :  printf( "Starting main loop through the rotations\n" ) ;
               :  printf( "PCA TIMING SHOULD stop here\n");
               :
               :  if (getrusage(RUSAGE_SELF, &usage) == -1) exit(0);
               :  end_utime = usage.ru_utime;
               :  end_stime = usage.ru_stime;
               :
               :  float utime = ((float)(end_utime.tv_sec) + (float)(end_utime.tv_usec/1000000.0)) - ((float)(start_utime.tv_sec) + (float)(start_utime.tv_usec/1000000.0));
               :
               :  float stime = ((float)(end_stime.tv_sec) + (float)(end_stime.tv_usec/1000000.0)) - ((float)(start_stime.tv_sec) + (float)(start_stime.tv_usec/1000000.0));
               :
               :  printf("\nUser time: %f || System time: %f\nCPU time (user+system): %f\n\n", utime, stime, utime+stime);
               :  fprintf(stderr, "%f\n", utime+stime);
               :  
               :  /* PCA: start comment
               :     for( rotation = first_rotation ; rotation <= Angles.n ; rotation ++ ) {
               :   * PCA: end comment 
               :   */
               :  for( rotation = first_rotation ; rotation <= 1/*Angles.n*/ ; rotation ++ ) {
               :
               :    printf( "." ) ; 
               :
               :    if( ( rotation % 50 ) == 0 ) printf( "\nRotation number %5d\n" , rotation ) ;
               :
               :    /* Rotate Mobile Structure */
               :    Rotated_at_Origin_Mobile_Structure =
               :     rotate_structure( Origin_Mobile_Structure , (int)Angles.z_twist[rotation] , (int)Angles.theta[rotation] , (int)Angles.phi[rotation] ) ;
               :
               :    /* Discretise the rotated Mobile Structure */
               :    discretise_structure( Rotated_at_Origin_Mobile_Structure , grid_span , global_grid_size , mobile_grid ) ;
               :
               :    /* Electic point charge approximation onto grid calculations ( quicker than filed calculations by a long way! ) */
               :    if( electrostatics == 1 ) {
               :      electric_point_charge( Rotated_at_Origin_Mobile_Structure , grid_span , global_grid_size , mobile_elec_grid ) ;
               :    }
               :
               :    /* Forward Fourier Transforms */
               :    rfftwnd_one_real_to_complex( p , mobile_grid , NULL ) ;
               :    if( electrostatics == 1 ) {
               :      rfftwnd_one_real_to_complex( p , mobile_elec_grid , NULL ) ;
               :    }
               :
               :/************/
               :
               :    /* Do convolution of the two sets of grids
               :       convolution is equivalent to multiplication of the complex conjugate of one
               :       fourier grid with other (raw) one
               :       hence the sign changes from a normal complex number multiplication
               :    */
               :
               :    for( fx = 0 ; fx < global_grid_size ; fx ++ ) {
     3 3.2e-04 :      for( fy = 0 ; fy < global_grid_size ; fy ++ ) {
   101  0.0107 :        for( fz = 0 ; fz < global_grid_size/2 + 1 ; fz ++ ) {
               :
               :          fxyz = fz + ( global_grid_size/2 + 1 ) * ( fy + global_grid_size * fx ) ;
               :
    22  0.0023 :          multiple_fsg[fxyz].re =
   136  0.0144 :           static_fsg[fxyz].re * mobile_fsg[fxyz].re + static_fsg[fxyz].im * mobile_fsg[fxyz].im ;
    11  0.0012 :          multiple_fsg[fxyz].im =
    23  0.0024 :           static_fsg[fxyz].im * mobile_fsg[fxyz].re - static_fsg[fxyz].re * mobile_fsg[fxyz].im ;
               :           
               :          if( electrostatics == 1 ) {
    17  0.0018 :            multiple_elec_fsg[fxyz].re =
    91  0.0096 :             static_elec_fsg[fxyz].re * mobile_elec_fsg[fxyz].re + static_elec_fsg[fxyz].im * mobile_elec_fsg[fxyz].im ;
    18  0.0019 :            multiple_elec_fsg[fxyz].im =
    42  0.0044 :             static_elec_fsg[fxyz].im * mobile_elec_fsg[fxyz].re - static_elec_fsg[fxyz].re * mobile_elec_fsg[fxyz].im ;
               :          }
               :
               :        }
               :      }
               :    }
               :
               :    /* Reverse Fourier Transform */
               :    rfftwnd_one_complex_to_real( pinv , multiple_fsg , NULL ) ;
               :    if( electrostatics == 1 ) {
               :      rfftwnd_one_complex_to_real( pinv , multiple_elec_fsg , NULL ) ;
               :    }
               :
               :/************/
               :
               :    /* Get best scores */
               :
               :    for( i = 0 ; i < keep_per_rotation ; i ++ ) {
               :
               :      Scores[i].score = 0 ;
               :      Scores[i].rpscore = 0.0 ;
               :      Scores[i].coord[1] = 0 ;
               :      Scores[i].coord[2] = 0 ;
               :      Scores[i].coord[3] = 0 ;
               :
               :    }
               :
               :    for( x = 0 ; x < global_grid_size ; x ++ ) {
               :      fx = x ;
               :      if( fx > ( global_grid_size / 2 ) ) fx -= global_grid_size ;
               :
               :      for( y = 0 ; y < global_grid_size ; y ++ ) {
               :        fy = y ;
               :        if( fy > ( global_grid_size / 2 ) ) fy -= global_grid_size ;
               :
   162  0.0171 :        for( z = 0 ; z < global_grid_size ; z ++ ) {
               :          fz = z ;
               :          if( fz > ( global_grid_size / 2 ) ) fz -= global_grid_size ;
               :
    47  0.0050 :          xyz = z + ( 2 * ( global_grid_size / 2 + 1 ) ) * ( y + global_grid_size * x ) ;
               :
   113  0.0120 :          if( ( electrostatics == 0 ) || ( convoluted_elec_grid[xyz] < 0 ) ) {
               :
               :            /* Scale factor from FFTs */
   194  0.0205 :            if( (int)convoluted_grid[xyz] != 0 ) {
   254  0.0269 :              convoluted_grid[xyz] /= ( global_grid_size * global_grid_size * global_grid_size ) ;
               :            }
               :
   145  0.0153 :            if( (int)convoluted_grid[xyz] > Scores[keep_per_rotation-1].score ) {
               :
               :              i = keep_per_rotation - 2 ;
               :
               :              while( ( (int)convoluted_grid[xyz] > Scores[i].score ) && ( i >= 0 ) ) {
               :                Scores[i+1].score    = Scores[i].score ;
               :                Scores[i+1].rpscore  = Scores[i].rpscore ;
               :                Scores[i+1].coord[1] = Scores[i].coord[1] ;
               :                Scores[i+1].coord[2] = Scores[i].coord[2] ;
               :                Scores[i+1].coord[3] = Scores[i].coord[3] ;
               :                i -- ;
               :              }
               :
               :              Scores[i+1].score    = (int)convoluted_grid[xyz] ;
               :              if( ( electrostatics != 0 ) && ( convoluted_elec_grid[xyz] < 0.1 ) ) {
               :                Scores[i+1].rpscore  = (float)convoluted_elec_grid[xyz] ;
               :              } else {
               :                Scores[i+1].rpscore  = (float)0 ;
               :              }
               :              Scores[i+1].coord[1] = fx ;
               :              Scores[i+1].coord[2] = fy ;
               :              Scores[i+1].coord[3] = fz ;
               :
               :            }
               :
               :          }
               :
               :        }
               :      }
               :    }
               :
               :    if( rotation == 1 ) {
               :      if( ( ftdock_file = fopen( "scratch_scores.dat" , "w" ) ) == NULL ) {
               :        printf( "Could not open scratch_scores.dat for writing.\nDying\n\n" ) ;
               :        exit( EXIT_FAILURE ) ;
               :      }
               :    } else {
               :      if( ( ftdock_file = fopen( "scratch_scores.dat" , "a" ) ) == NULL ) {
               :        printf( "Could not open scratch_scores.dat for writing.\nDying\n\n" ) ;
               :        exit( EXIT_FAILURE ) ;
               :      }
               :    }
               :
               :    for( i = 0 ; i < keep_per_rotation ; i ++ ) {
               :
               :      max_es_value = min( max_es_value , Scores[i].rpscore ) ;
               :      /* PCA: start comment
               :
               :      fprintf( ftdock_file, "G_DATA %6d   %6d    %7d       %.0f      %4d %4d %4d      %4d%4d%4d\n" ,
               :                rotation , 0 , Scores[i].score , (double)Scores[i].rpscore , Scores[i].coord[1] , Scores[i].coord[2] , Scores[i].coord[3 ] ,
               :                 Angles.z_twist[rotation] , Angles.theta[rotation]  , Angles.phi[rotation] ) ;
               :
               :       * PCA: Stop comment
               :       */
               :      fprintf( stdout, "G_DATA %6d   %6d    %7d       %4d %4d %4d      %4d%4d%4d\n" ,
               :                rotation , 0 , Scores[i].score , Scores[i].coord[1] , Scores[i].coord[2] , Scores[i].coord[3 ] ,
               :                 Angles.z_twist[rotation] , Angles.theta[rotation]  , Angles.phi[rotation] ) ;
               :
               :    }
               :
               :    fclose( ftdock_file ) ;
               :
               :    /* Free some memory */
               :    for( i = 1 ; i <= Rotated_at_Origin_Mobile_Structure.length ; i ++ ) {
               :      free( Rotated_at_Origin_Mobile_Structure.Residue[i].Atom ) ;
               :    }
               :    free( Rotated_at_Origin_Mobile_Structure.Residue ) ;
               :
               :  }
               :
               :  /* Finished main loop */
               :
               :/************/
               :
               :  /* Free the memory */
               :
               :  rfftwnd_destroy_plan( p ) ;
               :  rfftwnd_destroy_plan( pinv ) ;
               :
               :  free( static_grid ) ;
               :  free( mobile_grid ) ;
               :  free( convoluted_grid ) ;
               :
               :  if( electrostatics == 1 ) {
               :    free( static_elec_grid ) ;
               :    free( mobile_elec_grid ) ;
               :    free( convoluted_elec_grid ) ;
               :  }
               :
               :  for( i = 1 ; i <= Origin_Static_Structure.length ; i ++ ) {
               :    free( Origin_Static_Structure.Residue[i].Atom ) ;
               :  }
               :  free( Origin_Static_Structure.Residue ) ;
               :
               :  for( i = 1 ; i <= Origin_Mobile_Structure.length ; i ++ ) {
               :    free( Origin_Mobile_Structure.Residue[i].Atom ) ;
               :  }
               :  free( Origin_Mobile_Structure.Residue ) ;
               :
               :      /* PCA: Finishing programm here*/ 
               :      printf("PCA STOPS HERE\n");
               :      return 0;
               :      /* PCA: */
               :
               :
               :/************/
               :
               :  /* Read in all the scores */
               :
               :  printf( "\nReloading all the scores\n" ) ;
               :
               :  if( ( ftdock_file = fopen( "scratch_scores.dat" , "r" ) ) == NULL ) {
               :    printf( "Could not open scratch_scores.dat for reading.\nDying\n\n" ) ;
               :    exit( EXIT_FAILURE ) ;
               :  }
               :
               :  if( ( Scores = ( struct Score * ) realloc ( Scores , ( 1 + keep_per_rotation ) * Angles.n * sizeof( struct Score ) ) ) == NULL ) {
               :    printf( "Not enough memory left for storing scores\nProbably keeping too many per rotation\nDying\n\n" ) ;
               :    exit( EXIT_FAILURE ) ;
               :  }
               :
               :  kept_scores = 0 ;
               :
               :  while( fgets( line_buffer , 99 , ftdock_file ) ) {
               :
               :    sscanf( line_buffer , "G_DATA %d %d %d %f  %d %d %d  %d %d %d" , &id , &id2 , &SCscore , &RPscore ,
               :                                                                     &x , &y , &z , &z_twist , &theta , &phi ) ;
               :
               :    Scores[kept_scores].score    = SCscore ;
               :    Scores[kept_scores].rpscore  = RPscore ;
               :    Scores[kept_scores].coord[1] = x ;
               :    Scores[kept_scores].coord[2] = y ;
               :    Scores[kept_scores].coord[3] = z ;
               :    Scores[kept_scores].angle[1] = z_twist ;
               :    Scores[kept_scores].angle[2] = theta ;
               :    Scores[kept_scores].angle[3] = phi ;
               :
               :    kept_scores ++ ;
               :
               :  }
               :
               :  fclose( ftdock_file ) ;
               :
               :  kept_scores -- ;
               :
               :  qsort_scores( Scores , 0 , kept_scores ) ;
               :
               :/************/
               :
               :  /* Writing data file */
               :
               :  if( ( ftdock_file = fopen( output_file_name , "w" ) ) == NULL ) {
               :    printf( "Could not open %s for writing.\nDying\n\n" , output_file_name ) ;
               :    exit( EXIT_FAILURE ) ;
               :  }
               :
               :  fprintf( ftdock_file, "FTDOCK data file\n" ) ;
               :
               :  fprintf( ftdock_file, "\nGlobal Scan\n" ) ;
               :
               :  fprintf( ftdock_file, "\nCommand line controllable values\n" ) ;
               :  fprintf( ftdock_file, "Static molecule                    :: %s\n" , static_file_name ) ;
               :  fprintf( ftdock_file, "Mobile molecule                    :: %s\n" , mobile_file_name ) ;
               :  fprintf( ftdock_file, "\n" ) ;
               :  fprintf( ftdock_file, "Global grid size                   :: %6d      %s\n" , global_grid_size , default_global_grid_size ) ;
               :  fprintf( ftdock_file, "Global search angle step           :: %6d      %s\n" , angle_step , default_angle_step ) ;
               :  fprintf( ftdock_file, "Global surface thickness           :: %9.2f   %s\n" , surface , default_surface ) ;
               :  fprintf( ftdock_file, "Global internal deterrent value    :: %9.2f   %s\n" , internal_value , default_internal_value ) ;
               :  if( electrostatics == 1 ) {
               :    fprintf( ftdock_file, "Electrostatics                     ::     on      %s\n" , default_electrostatics ) ;
               :  } else {
               :    fprintf( ftdock_file, "Electrostatics                     ::    off      %s\n" , default_electrostatics ) ;
               :  }
               :  fprintf( ftdock_file, "Global keep per rotation           :: %6d      %s\n" , keep_per_rotation , default_keep_per_rotation ) ;
               :
               :  fprintf( ftdock_file, "\nCalculated values\n" ) ;
               :  fprintf( ftdock_file, "Global rotations                   :: %6d\n" , Angles.n ) ;
               :  fprintf( ftdock_file, "Global total span (angstroms)      :: %10.3f\n" , grid_span ) ;
               :  fprintf( ftdock_file, "Global grid cell span (angstroms)  :: %10.3f\n" , one_span ) ;
               :
               :  fprintf( ftdock_file, "\nData\n" ) ;
               :  fprintf( ftdock_file , "Type       ID    prvID    SCscore        ESratio         Coordinates            Angles\n\n" ) ;
               :
               :  if( electrostatics == 1 ) {
               :
               :    for( i = 0 ; i <= min( kept_scores , ( NUMBER_TO_KEEP - 1 ) ) ; i ++ ) {
               :
               :      fprintf( ftdock_file, "G_DATA %6d   %6d    %7d       %8.3f      %4d %4d %4d      %4d%4d%4d\n" ,
               :               i + 1 , 0 , Scores[i].score , 100 * ( Scores[i].rpscore / max_es_value ) ,
               :               Scores[i].coord[1] , Scores[i].coord[2] , Scores[i].coord[3] ,
               :               Scores[i].angle[1] , Scores[i].angle[2] , Scores[i].angle[3] ) ;
               :
               :    }
               :
               :  } else {
               :
               :    for( i = 0 ; i <= min( kept_scores , ( NUMBER_TO_KEEP - 1 ) ) ; i ++ ) {
               :
               :      fprintf( ftdock_file, "G_DATA %6d   %6d    %7d       %8.3f      %4d %4d %4d      %4d%4d%4d\n" ,
               :               i + 1 , 0 , Scores[i].score , 0.0 ,
               :               Scores[i].coord[1] , Scores[i].coord[2] , Scores[i].coord[3] ,
               :               Scores[i].angle[1] , Scores[i].angle[2] , Scores[i].angle[3] ) ;
               :
               :    }
               :
               :  }
               :
               :  fclose( ftdock_file ) ;
               :    
               :/************/
               :
               :  printf( "\n\nFinished\n\n" ) ;
               :
               :  return( 0 ) ;
               :
               :} /* end main */
/* 
 * Total samples for file : "/home2/users/alumnes/1125822/dades/linux/PCA/ProjecteFinal/finalProject1213q2/sources/3D_Dock/progs/coordinates.c"
 * 
 *    666  0.0705
 */


               :/*
               :This file is part of ftdock, a program for rigid-body protein-protein docking 
               :Copyright (C) 1997-2000 Gidon Moont
               :
               :Biomolecular Modelling Laboratory
               :Imperial Cancer Research Fund
               :44 Lincoln's Inn Fields
               :London WC2A 3PX
               :
               :+44 (0)20 7269 3348
               :http://www.bmm.icnet.uk/
               :
               :This program is free software; you can redistribute it and/or
               :modify it under the terms of the GNU General Public License
               :as published by the Free Software Foundation; either version 2
               :of the License, or (at your option) any later version.
               :
               :This program is distributed in the hope that it will be useful,
               :but WITHOUT ANY WARRANTY; without even the implied warranty of
               :MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :GNU General Public License for more details.
               :
               :You should have received a copy of the GNU General Public License
               :along with this program; if not, write to the Free Software
               :Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
               :
               :*/
               :
               :#include "structures.h"
               :
               :/************/
               :
               :int gord( float position , float grid_span , int grid_size ) { /* gord total:      3 3.2e-04 */
               :
               :  int ordinate ;
               :
               :  float one_span = grid_span / (float)grid_size ;
               :
               :  ordinate = (int)( position / one_span ) + ( grid_size / 2 ) ;
               :
     3 3.2e-04 :  if( position < 0 ) ordinate -= 1 ;
               :
               :  return ordinate ;
               :
               :}
               :
               :/************/
               :
    28  0.0030 :float pythagoras( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { /* pythagoras total:    663  0.0702 */
               :
   137  0.0145 :  return sqrt( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) + ( ( z1 - z2 ) * ( z1 - z2 ) ) ) ;
               :
   498  0.0527 :}
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/stdio-common/vfscanf.c"
 * 
 *    107  0.0113
 */


 /* _IO_vfscanf_internal total:    107  0.0113 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/stdlib/strtod_l.c"
 * 
 *     54  0.0057
 */


 /* round_and_return total:      9 9.5e-04 */
 /* str_to_mpn.isra.0 total:     10  0.0011 */
 /* ____strtof_l_internal total:     35  0.0037 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/string/../sysdeps/i386/i586/memcpy.S"
 * 
 *     25  0.0026
 */


 /* memcpy total:     25  0.0026 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/libio/genops.c"
 * 
 *     21  0.0022
 */


 /* _IO_setb total:      7 7.4e-04 */
 /* _IO_default_uflow total:      1 1.1e-04 */
 /* _IO_old_init total:      5 5.3e-04 */
 /* _IO_no_init total:      5 5.3e-04 */
 /* _IO_sputbackc total:      3 3.2e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/string/../sysdeps/i386/rawmemchr.S"
 * 
 *     17  0.0018
 */


 /* rawmemchr total:     17  0.0018 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/stdlib/../sysdeps/i386/i586/lshift.S"
 * 
 *      9 9.5e-04
 */


 /* __mpn_lshift total:      9 9.5e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/stdio-common/isoc99_vsscanf.c"
 * 
 *      7 7.4e-04
 */


 /* __isoc99_vsscanf total:      7 7.4e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/libio/strops.c"
 * 
 *      7 7.4e-04
 */


 /* _IO_str_init_static_internal total:      7 7.4e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/time/../sysdeps/unix/syscall-template.S"
 * 
 *      6 6.3e-04
 */


 /* gettimeofday total:      6 6.3e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/stdlib/strtol_l.c"
 * 
 *      6 6.3e-04
 */


 /* ____strtol_l_internal total:      6 6.3e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/stdlib/strtod.c"
 * 
 *      6 6.3e-04
 */


 /* __strtof_internal total:      6 6.3e-04 */
/* 
 * Total samples for file : "/home2/users/alumnes/1125822/dades/linux/PCA/ProjecteFinal/finalProject1213q2/sources/3D_Dock/progs/manipulate_structures.c"
 * 
 *      5 5.3e-04
 */


               :/*
               :This file is part of ftdock, a program for rigid-body protein-protein docking 
               :Copyright (C) 1997-2000 Gidon Moont
               :
               :Biomolecular Modelling Laboratory
               :Imperial Cancer Research Fund
               :44 Lincoln's Inn Fields
               :London WC2A 3PX
               :
               :+44 (0)20 7269 3348
               :http://www.bmm.icnet.uk/
               :
               :This program is free software; you can redistribute it and/or
               :modify it under the terms of the GNU General Public License
               :as published by the Free Software Foundation; either version 2
               :of the License, or (at your option) any later version.
               :
               :This program is distributed in the hope that it will be useful,
               :but WITHOUT ANY WARRANTY; without even the implied warranty of
               :MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :GNU General Public License for more details.
               :
               :You should have received a copy of the GNU General Public License
               :along with this program; if not, write to the Free Software
               :Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
               :
               :*/
               :
               :#include "structures.h"
               :
               :struct Structure read_pdb_to_structure( char *pdb_file_name ) { /* read_pdb_to_structure total:      4 4.2e-04 */
               :
               :/************/
               :
               :  /* Variables */
               :
               :  /* Counters */
               :  int	n_residues ;	/* number of residues */
               :  int	res_size ;	/* number of atoms in single residue */
               :
               :  /* File stuff */
               :  FILE	*pdb_file ;
               :  char	line_buffer[100] ;
               :
               :  /* What the data is going into */
               :  struct Structure		This_Structure ;
               :
               :  /* Variables from the PDB file */
               :  int	serial ;
               :  char		atom_name[5] ;
               :  char		res_name[4] ;
               :  char		chainID[2] ;
               :  char		res_seq_plus_iCode[6] ;
               :  float		coord_x , coord_y , coord_z ;
               :  float		occupancy, temp_factor ;
               :  char		olc[2] ;
               :  int		nc ;
               :
               :  /* Comparison values */
               :  char	present_res_seq_plus_iCode[6] ;
               :
               :/************/
               :
               :  setvbuf( stdout , (char *)NULL , _IONBF , 0 ) ;
               :
               :  /* File handling */
               :
               :  /* Open file */
               :  printf( "  reading parsed pdb file: %s\n", pdb_file_name ) ;
               :  if( ( pdb_file = fopen( pdb_file_name, "r" ) ) == NULL ) {
               :    printf( "This file does not exist here, or is unreadable.\nDying\n\n" ) ;
               :    exit( EXIT_FAILURE ) ;
               :  }
               :
               :/************/
               :
               :  /* Initialisations */
               :
               :  /* Counters */
               :  n_residues = 0 ;
               :  res_size = 0 ;
               :
               :  /* Comparison values */
               :  strcpy( present_res_seq_plus_iCode , ">" ) ;
               :
               :  /* Memory allocation */
               :  if( ( This_Structure.Residue = ( struct Amino_Acid * ) malloc ( sizeof_Amino_Acid ) ) == NULL ) {
               :    GENERAL_MEMORY_PROBLEM
               :  }
               :
               :/************/
               :
               :  /* Read PDB file */
               :
               :  /* The Atoms */
               :
     1 1.1e-04 :  while( fgets( line_buffer, 85, pdb_file ) ) {
               :
               :    if( strncmp( line_buffer, "ATOM", 4 ) == 0 ) {
               :
               :      /* Have an ATOM */
               :
               :      /* Get Values */
               :
               :      /* the following may seem silly, but sscanf convention means that two
               :         float fields with no white space between them, where the first is
               :         less than the maximum field width, mucks up everything.
               :      */
               :
               :      sscanf( line_buffer +  6 , "%5d" , &serial ) ;
               :      sscanf( line_buffer + 30 , "%8f" , &coord_x ) ;
               :      sscanf( line_buffer + 38 , "%8f" , &coord_y ) ;
               :      sscanf( line_buffer + 46 , "%8f" , &coord_z ) ;
               :      sscanf( line_buffer + 54 , "%6f" , &occupancy ) ;
               :      sscanf( line_buffer + 60 , "%6f" , &temp_factor ) ;
               :      sscanf( line_buffer + 82 , "%2d" , &nc ) ;
               :
               :      strncpy( atom_name,		line_buffer+12,	4 ) ;
               :      strncpy( res_name,		line_buffer+17,	3 ) ;
     1 1.1e-04 :      strncpy( chainID,			line_buffer+21,	1 ) ;
               :      strncpy( res_seq_plus_iCode,	line_buffer+22,	5 ) ;
     1 1.1e-04 :      strncpy( olc,			line_buffer+80,	1 ) ;
               :
               :      strncpy( atom_name + 4,		"\0", 1 ) ;
               :      strncpy( res_name + 3,		"\0", 1 ) ;
               :      strncpy( chainID + 1,		"\0", 1 ) ;
               :      strncpy( res_seq_plus_iCode + 5,	"\0", 1 ) ;
               :      strncpy( olc + 1,			"\0", 1 ) ;
               :
               :/************/
               :
               :      /* New Residue */
               :
     1 1.1e-04 :      if( strcmp( res_seq_plus_iCode , present_res_seq_plus_iCode ) != 0 ) {
               :
               :        /* have next residue */
               :
               :        /* Store old info */
               :        This_Structure.Residue[n_residues].size = res_size ;
               :
               :        /* Increment, Reset numbers */
               :        n_residues ++ ;
               :        res_size = 0 ;
               :
               :        /* Memory management */
               :        if( ( This_Structure.Residue = (struct Amino_Acid * ) realloc ( This_Structure.Residue, ( n_residues + 1 ) * sizeof_Amino_Acid ) ) == NULL ) {
               :          GENERAL_MEMORY_PROBLEM
               :        }
               :        if( ( This_Structure.Residue[n_residues].Atom = ( struct Atom * ) malloc ( sizeof_Atom ) ) == NULL ) {
               :          GENERAL_MEMORY_PROBLEM
               :        }
               :
               :        /* Store new info */
               :        strcpy( This_Structure.Residue[n_residues].res_seq_plus_iCode , res_seq_plus_iCode );
               :        strcpy( This_Structure.Residue[n_residues].res_name ,           res_name ) ;
               :        strcpy( This_Structure.Residue[n_residues].chainID ,            chainID ) ;
               :        strcpy( This_Structure.Residue[n_residues].olc,                 olc ) ;
               :        This_Structure.Residue[n_residues].nc = nc ;
               :
               :      }
               :
               :      strcpy( present_res_seq_plus_iCode , res_seq_plus_iCode ) ;
               :
               :/************/
               :
               :      /* Put Atoms into Structure */
               :
               :      res_size ++ ;
               :
               :      if( ( This_Structure.Residue[n_residues].Atom = ( struct Atom * ) realloc ( This_Structure.Residue[n_residues].Atom, ( res_size + 1 ) * sizeof_Atom ) ) == NULL ) {
               :        GENERAL_MEMORY_PROBLEM
               :      }
               :
               :      This_Structure.Residue[n_residues].Atom[res_size].serial = serial ;
               :      strcpy( This_Structure.Residue[n_residues].Atom[res_size].atom_name, atom_name ) ;
               :      This_Structure.Residue[n_residues].Atom[res_size].coord[1] = coord_x ;
               :      This_Structure.Residue[n_residues].Atom[res_size].coord[2] = coord_y ;
               :      This_Structure.Residue[n_residues].Atom[res_size].coord[3] = coord_z ;
               :      This_Structure.Residue[n_residues].Atom[res_size].occupancy = occupancy ;
               :      This_Structure.Residue[n_residues].Atom[res_size].temp_factor = temp_factor ;
               :
               :/************/
               :
               :    }
               :
               :  } /* got to end of pdb file */
               :
               :/************/
               :
               :  /* Clean up */
               :
               :  This_Structure.Residue[n_residues].size = res_size ;
               :  This_Structure.length = n_residues ;
               :  strcpy( This_Structure.ident , pdb_file_name  );
               :
               :  /* Finish off */
               :
               :  fclose( pdb_file ) ;
               :
               :  return This_Structure ;
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :void write_structure_to_pdb( struct Structure This_Structure , char *pdb_file_name ) {
               :
               :/************/
               :
               :  /* Variables */
               :
               :  /* Counters */
               :  int	residue , atom ;
               :
               :  /* File stuff */
               :  FILE		*pdb_file ;
               :
               :/************/
               :
               :  /* File handling */
               :
               :  /* Open file */
               :  printf( "Writing file: %s\n", pdb_file_name ) ;
               :  if( ( pdb_file = fopen( pdb_file_name, "w" ) ) == NULL ) {
               :    printf( "This file could not be opened.\nDying\n\n" ) ;
               :    exit(  EXIT_FAILURE ) ;
               :  }
               :
               :/************/
               :
               :  /* Write PDB file */
               :
               :  for( residue = 1 ; residue <= This_Structure.length ; residue ++ ) {
               :
               :    for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      fprintf( pdb_file, "ATOM  %5d %4s %3s %1s%5s   %8.3f%8.3f%8.3f%6.2f%6.2f              %1s %2d\n", This_Structure.Residue[residue].Atom[atom].serial, This_Structure.Residue[residue].Atom[atom].atom_name, This_Structure.Residue[residue].res_name, This_Structure.Residue[residue].chainID, This_Structure.Residue[residue].res_seq_plus_iCode, This_Structure.Residue[residue].Atom[atom].coord[1], This_Structure.Residue[residue].Atom[atom].coord[2], This_Structure.Residue[residue].Atom[atom].coord[3], This_Structure.Residue[residue].Atom[atom].occupancy, This_Structure.Residue[residue].Atom[atom].temp_factor, This_Structure.Residue[residue].olc, This_Structure.Residue[residue].nc ) ;
               :
               :    }
               :
               :  }
               :
               :/************/
               :
               :  /* Finish off */
               :
               :  fclose( pdb_file ) ;
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :struct Structure duplicate_structure( struct Structure This_Structure ) { /* duplicate_structure total:      1 1.1e-04 */
               :
               :/************/
               :
               :  /* Variables */
               :  struct Structure	New_Structure ;
               :
               :  /* Counters */
               :  int		residue , atom ;
               :
               :/************/
               :
               :  if( ( New_Structure.Residue = ( struct Amino_Acid * ) malloc ( ( This_Structure.length + 1 ) * sizeof_Amino_Acid ) ) == NULL ) {
               :    GENERAL_MEMORY_PROBLEM
               :  }
               :
               :  strcpy( New_Structure.ident , This_Structure.ident ) ;
               :  New_Structure.length = This_Structure.length ;
               :
               :  for( residue = 1 ; residue <= This_Structure.length ; residue ++ ) {
               :
               :    New_Structure.Residue[residue] = This_Structure.Residue[residue] ;
               :
               :    if( ( New_Structure.Residue[residue].Atom = ( struct Atom * ) malloc ( ( This_Structure.Residue[residue].size + 1 ) * sizeof_Atom ) ) == NULL ) {
               :      GENERAL_MEMORY_PROBLEM
               :    }
               :
               :    for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom ++ ) {
               :
     1 1.1e-04 :      New_Structure.Residue[residue].Atom[atom] = This_Structure.Residue[residue].Atom[atom] ;
               :
               :    }
               :
               :  }
               :
               :  return New_Structure ;
               :
               :/************/
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :struct Structure translate_structure( struct Structure This_Structure , float x_shift , float y_shift , float z_shift ) {
               :
               :/************/
               :
               :  /* Variables */
               :  struct Structure	New_Structure ;
               :
               :  /* Counters */
               :  int		residue , atom ;
               :
               :/************/
               :
               :  New_Structure = duplicate_structure( This_Structure ) ;
               :
               :/************/
               :
               :  for( residue = 1 ; residue <= New_Structure.length ; residue ++ ) {
               :
               :    for( atom = 1 ; atom <= New_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      New_Structure.Residue[residue].Atom[atom].coord[1] += x_shift ;
               :      New_Structure.Residue[residue].Atom[atom].coord[2] += y_shift ;
               :      New_Structure.Residue[residue].Atom[atom].coord[3] += z_shift ;
               :
               :    }
               :
               :  }
               :
               :  return New_Structure ;
               :
               :/************/
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :struct Structure translate_structure_onto_origin( struct Structure This_Structure ) {
               :
               :/************/
               :
               :  /* Variables */
               :  struct Structure	New_Structure ;
               :
               :  float			average_x , average_y , average_z ;
               :
               :  /* Counters */
               :  int		residue , atom , total_atoms ;
               :
               :/************/
               :
               :  New_Structure = duplicate_structure( This_Structure ) ;
               :
               :/************/
               :
               :  /* Find current centre */
               :
               :  total_atoms = 0 ;
               :
               :  average_x = 0 ;
               :  average_y = 0 ;
               :  average_z = 0 ;
               :
               :  for( residue = 1 ; residue <= New_Structure.length ; residue ++ ) {
               :
               :    for( atom = 1 ; atom <= New_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      total_atoms ++ ;
               :
               :      average_x += New_Structure.Residue[residue].Atom[atom].coord[1] ;
               :      average_y += New_Structure.Residue[residue].Atom[atom].coord[2] ;
               :      average_z += New_Structure.Residue[residue].Atom[atom].coord[3] ;
               :
               :    }
               :
               :  }
               :
               :  average_x = average_x / (float)total_atoms ;
               :  average_y = average_y / (float)total_atoms ;
               :  average_z = average_z / (float)total_atoms ;
               :
               :/************/
               :
               :  /* Translate */
               :
               :  for( residue = 1 ; residue <= New_Structure.length ; residue ++ ) {
               :
               :    for( atom = 1 ; atom <= New_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      New_Structure.Residue[residue].Atom[atom].coord[1] -= average_x ;
               :      New_Structure.Residue[residue].Atom[atom].coord[2] -= average_y ;
               :      New_Structure.Residue[residue].Atom[atom].coord[3] -= average_z ;
               :
               :    }
               :
               :  }
               :
               :  return New_Structure ;
               :
               :/************/
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :struct Structure rotate_structure( struct Structure This_Structure , int z_twist , int theta , int phi ) {
               :
               :/************/
               :
               :  /* Variables */
               :  struct Structure	New_Structure ;
               :
               :  float			post_z_twist_x , post_z_twist_y , post_z_twist_z ;
               :  float			post_theta_x , post_theta_y , post_theta_z ;
               :
               :  /* Counters */
               :  int		residue , atom ;
               :
               :/************/
               :
               :  New_Structure = duplicate_structure( This_Structure ) ;
               :
               :/************/
               :
               :  for( residue = 1 ; residue <= New_Structure.length ; residue ++ ) {
               :
               :    for( atom = 1 ; atom <= New_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      /* Perform Z axis twist */
               :      post_z_twist_x = New_Structure.Residue[residue].Atom[atom].coord[1] * cos( 0.017453293 * z_twist ) - New_Structure.Residue[residue].Atom[atom].coord[2] * sin( 0.017453293 * z_twist ) ;
               :      post_z_twist_y = New_Structure.Residue[residue].Atom[atom].coord[1] * sin( 0.017453293 * z_twist ) + New_Structure.Residue[residue].Atom[atom].coord[2] * cos( 0.017453293 * z_twist ) ;
               :      post_z_twist_z = New_Structure.Residue[residue].Atom[atom].coord[3] ;
               :
               :      /* Perform theta twist along plane of x-z */
               :      post_theta_x = post_z_twist_z * sin( 0.017453293 * theta ) + post_z_twist_x * cos( 0.017453293 * theta ) ; 
               :      post_theta_y = post_z_twist_y ;
               :      post_theta_z = post_z_twist_z * cos( 0.017453293 * theta ) - post_z_twist_x * sin( 0.017453293 * theta ) ; 
               :
               :      /* Perform phi twist around z axis */
               :      New_Structure.Residue[residue].Atom[atom].coord[1] = post_theta_x * cos( 0.017453293 * phi ) - post_theta_y * sin( 0.017453293 * phi ) ;
               :      New_Structure.Residue[residue].Atom[atom].coord[2] = post_theta_x * sin( 0.017453293 * phi ) + post_theta_y * cos( 0.017453293 * phi ) ;
               :      New_Structure.Residue[residue].Atom[atom].coord[3] = post_theta_z ;
               :
               :    }
               :
               :  }
               :
               :  return New_Structure ;
               :
               :/************/
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :struct Structure merge_structures( struct Structure Structure_One , struct Structure Structure_Two ) {
               :
               :/************/
               :
               :  /* Variables */
               :  struct Structure	New_Structure ;
               :
               :  /* Counters */
               :  int		residue , atom , new_residue ;
               :
               :/************/
               :
               :  if( ( New_Structure.Residue = ( struct Amino_Acid * ) malloc ( ( Structure_One.length + Structure_Two.length + 1 ) * sizeof_Amino_Acid ) ) == NULL ) {
               :    GENERAL_MEMORY_PROBLEM
               :  }
               :
               :  strcpy( New_Structure.ident , "Complex" ) ;
               :  New_Structure.length = Structure_One.length + Structure_Two.length ;
               :
               :  for( residue = 1 ; residue <= Structure_One.length ; residue ++ ) {
               :
               :    if( ( New_Structure.Residue[residue].Atom = ( struct Atom * ) malloc ( ( Structure_One.Residue[residue].size + 1 ) * sizeof_Atom ) ) == NULL ) {
               :      GENERAL_MEMORY_PROBLEM
               :    }
               :    strcpy( New_Structure.Residue[residue].res_name           , Structure_One.Residue[residue].res_name ) ;
               :    strcpy( New_Structure.Residue[residue].chainID            , Structure_One.Residue[residue].chainID ) ;
               :    strcpy( New_Structure.Residue[residue].res_seq_plus_iCode , Structure_One.Residue[residue].res_seq_plus_iCode ) ;
               :    strcpy( New_Structure.Residue[residue].olc                , Structure_One.Residue[residue].olc ) ;
               :    New_Structure.Residue[residue].nc                         = Structure_One.Residue[residue].nc   ;
               :    New_Structure.Residue[residue].size                       = Structure_One.Residue[residue].size ;
               :
               :    if( ( New_Structure.Residue[residue].Atom = ( struct Atom * ) malloc ( ( Structure_One.Residue[residue].size + 1 ) * sizeof_Atom ) ) == NULL ) {
               :      GENERAL_MEMORY_PROBLEM
               :    }
               :
               :    for( atom = 1 ; atom <= Structure_One.Residue[residue].size ; atom ++ ) {
               :
               :      New_Structure.Residue[residue].Atom[atom] = Structure_One.Residue[residue].Atom[atom] ;
               :
               :    }
               :
               :  }
               :
               :  for( residue = 1 ; residue <= Structure_Two.length ; residue ++ ) {
               :
               :    new_residue = residue + Structure_One.length ;
               :
               :    strcpy( New_Structure.Residue[new_residue].chainID            , Structure_Two.Residue[residue].chainID ) ;
               :    strcpy( New_Structure.Residue[new_residue].res_seq_plus_iCode , Structure_Two.Residue[residue].res_seq_plus_iCode ) ;
               :    strcpy( New_Structure.Residue[new_residue].olc                , Structure_Two.Residue[residue].olc ) ;
               :    New_Structure.Residue[new_residue].nc                         = Structure_Two.Residue[residue].nc   ;
               :    New_Structure.Residue[new_residue].size                       = Structure_Two.Residue[residue].size ;
               :    strcpy( New_Structure.Residue[new_residue].res_name           , Structure_Two.Residue[residue].res_name ) ;
               :
               :    if( ( New_Structure.Residue[new_residue].Atom = ( struct Atom * ) malloc ( ( Structure_Two.Residue[residue].size + 1 ) * sizeof_Atom ) ) == NULL ) {
               :      GENERAL_MEMORY_PROBLEM
               :    }
               :    for( atom = 1 ; atom <= Structure_Two.Residue[residue].size ; atom ++ ) {
               :
               :      New_Structure.Residue[new_residue].Atom[atom] = Structure_Two.Residue[residue].Atom[atom] ;
               :
               :    }
               :
               :  }
               :
               :  return New_Structure ;
               :
               :/************/
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :float radius_of_structure( struct Structure This_Structure ) {
               :
               :/************/
               :
               :  /* Variables */
               :  float		present , largest ;
               :
               :  /* Counters */
               :  int	residue , atom ;
               :
               :/************/
               :
               :  largest = 0 ;
               :
               :  for( residue = 1 ; residue <= This_Structure.length ; residue ++ ) {
               :
               :    for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      present = This_Structure.Residue[residue].Atom[atom].coord[1] * This_Structure.Residue[residue].Atom[atom].coord[1] + This_Structure.Residue[residue].Atom[atom].coord[2] * This_Structure.Residue[residue].Atom[atom].coord[2] + This_Structure.Residue[residue].Atom[atom].coord[3] * This_Structure.Residue[residue].Atom[atom].coord[3] ;
               :
               :      if( present > largest ) largest = present ;
               :
               :    }
               :
               :  }
               :
               :  return sqrt( largest ) ;
               :
               :/************/
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :float total_span_of_structures( struct Structure Structure_1 , struct Structure Structure_2 ) {
               :
               :  return  1 + ( ( radius_of_structure( Structure_1 ) + radius_of_structure( Structure_2 ) ) * 2 ) ;
               :
               :}
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/string/strncpy.c"
 * 
 *      4 4.2e-04
 */


 /* strncpy total:      4 4.2e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/string/../sysdeps/i386/memchr.S"
 * 
 *      4 4.2e-04
 */


 /* memchr total:      4 4.2e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/string/../sysdeps/i386/i586/strlen.S"
 * 
 *      4 4.2e-04
 */


 /* strlen total:      4 4.2e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/stdlib/../sysdeps/ieee754/flt-32/mpn2flt.c"
 * 
 *      4 4.2e-04
 */


 /* __mpn_construct_float total:      4 4.2e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/stdlib/../sysdeps/i386/i586/mul_1.S"
 * 
 *      4 4.2e-04
 */


 /* __mpn_mul_1 total:      4 4.2e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/libio/iogetline.c"
 * 
 *      4 4.2e-04
 */


 /* _IO_getline total:      1 1.1e-04 */
 /* _IO_getline_info total:      3 3.2e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/stdlib/mul.c"
 * 
 *      3 3.2e-04
 */


 /* __mpn_mul total:      3 3.2e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/libio/iofgets.c"
 * 
 *      3 3.2e-04
 */


 /* fgets total:      3 3.2e-04 */
/* 
 * Total samples for file : "rfftwnd.c"
 * 
 *      2 2.1e-04
 */

<credited to line zero>      2 2.1e-04 :
 /* rfftwnd_real2c_aux.constprop.4 total:      2 2.1e-04 */
/* 
 * Total samples for file : "/home2/users/alumnes/1125822/dades/linux/PCA/ProjecteFinal/finalProject1213q2/sources/3D_Dock/progs/angles.c"
 * 
 *      2 2.1e-04
 */


               :/*
               :This file is part of ftdock, a program for rigid-body protein-protein docking 
               :Copyright (C) 1997-2000 Henry Gabb/Gidon Moont
               :
               :Biomolecular Modelling Laboratory
               :Imperial Cancer Research Fund
               :44 Lincoln's Inn Fields
               :London WC2A 3PX
               :
               :+44 (0)20 7269 3565
               :http://www.bmm.icnet.uk/
               :
               :This program is free software; you can redistribute it and/or
               :modify it under the terms of the GNU General Public License
               :as published by the Free Software Foundation; either version 2
               :of the License, or (at your option) any later version.
               :
               :This program is distributed in the hope that it will be useful,
               :but WITHOUT ANY WARRANTY; without even the implied warranty of
               :MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :GNU General Public License for more details.
               :
               :You should have received a copy of the GNU General Public License
               :along with this program; if not, write to the Free Software
               :Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
               :
               :*/
               :
               :#include "structures.h"
               :
     2 2.1e-04 :struct Angle generate_global_angles( int angle_step ) { /* generate_global_angles total:      2 2.1e-04 */
               :
               :/************/
               :
               :  /* Counters */
               :
               :  int		n ;
               :
               :  /* Variables */
               :
               :  int		z_twist , theta , phi ;
               :  int		phi_step_for_this_theta ;
               :
               :  /* What the data is going into */
               :  struct Angle		Angles ;
               :
               :/************/
               :
               :  if( ( Angles.z_twist = ( int * ) malloc ( MAX_ROTATIONS * sizeof( int ) ) ) &&
               :      ( Angles.theta   = ( int * ) malloc ( MAX_ROTATIONS * sizeof( int ) ) ) &&
               :      ( Angles.phi     = ( int * ) malloc ( MAX_ROTATIONS * sizeof( int ) ) ) ) {
               :  } else {
               :    GENERAL_MEMORY_PROBLEM
               :  }
               :
               :  n = 0 ;
               :
               :  theta = 0 ;
               :  phi = 0 ;
               :
               :/************/
               :
               :  if( ( 180 % angle_step ) != 0 ) {
               :
               :    printf( "Bad angle step chosen\nPlease choose a value which is an integer factor of 180\nDying\n\n" ) ;
               :    exit( EXIT_FAILURE ) ;
               :
               :  }
               :
               :  if( angle_step < 9 ) {
               :
               :    printf( "Sorry, but I refuse to do so many rotations (more than 70 thousand).  Think again.\nIf you insist then you will have to check the byte size of an integer on your machine and possibly change all my ints to longs\nDying\n\n" ) ;
               :    exit( EXIT_FAILURE ) ;
               :
               :  }
               :
               :/************/
               :
               :  for( z_twist = 0 ; z_twist < 360 ; z_twist += angle_step ) {
               :
               :    n ++ ;
               :
               :    Angles.z_twist[n] = z_twist ;
               :    Angles.theta[n]   = 0 ;
               :    Angles.phi[n]     = 0 ;
               :
               :  }
               :
               :  for( theta = angle_step ; theta < 180 ; theta += angle_step ) {
               :
               :    phi_step_for_this_theta = 57.29578 * acos( ( cos( 0.017453293 * angle_step ) - ( cos( 0.017453293 * theta ) * cos( 0.017453293 * theta ) ) ) / ( sin( 0.017453293 * theta ) * sin( 0.017453293 * theta ) ) ) ;
               :
               :    while( ( 360 % phi_step_for_this_theta ) != 0 ) phi_step_for_this_theta -- ;
               :
               :    for( phi = 0 ; phi < 360 ; phi += phi_step_for_this_theta ) {
               :
               :      for( z_twist = 0 ; z_twist < 360 ; z_twist += angle_step ) {
               :
               :        n ++ ;
               :
               :        Angles.z_twist[n] = z_twist ;
               :        Angles.theta[n]   = theta ;
               :        Angles.phi[n]     = phi ;
               :
               :      }
               :
               :    }
               :
               :  }
               :
               :  for( z_twist = 0 ; z_twist < 360 ; z_twist += angle_step ) {
               :
               :    n ++ ;
               :
               :    Angles.z_twist[n] = z_twist ;
               :    Angles.theta[n]   = 180 ;
               :    Angles.phi[n]     = 0 ;
               :
               :  }
               :
               :/************/
               :
               :  if( n >= MAX_ROTATIONS ) {
               :
               :    printf( "You have exceeded the MAX_ROTATIONS constant.\nEither choose a larger angle_step or recompile after editing structures.h\nDying\n\n" ) ;
               :    exit( EXIT_FAILURE ) ;
               :
               :  }
               :
               :  if( ( Angles.z_twist = ( int * ) realloc ( Angles.z_twist  , ( 1 + n ) * sizeof( int ) ) ) &&
               :      ( Angles.theta   = ( int * ) realloc ( Angles.theta    , ( 1 + n ) * sizeof( int ) ) ) &&
               :      ( Angles.phi     = ( int * ) realloc ( Angles.phi      , ( 1 + n ) * sizeof( int ) ) ) ) {
               :  } else {
               :    GENERAL_MEMORY_PROBLEM
               :  }
               :
               :  Angles.n = n ;
               :
               :/************/
               :
               :  return Angles ;
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :struct Angle generate_range_of_angles( int angle_step , int angle_range , int z_twist , int theta , int phi ) {
               :
               :/************/
               :
               :  /* Counters */
               :
               :  int		n ;
               :
               :  /* Variables */
               :
               :  int		z_twist_step , theta_step , phi_step ;
               :  int		phi_step_for_this_theta ;
               :  int		this_z_twist_step , this_phi_step ;
               :
               :  /* What the data is going into */
               :  struct Angle		Angles ;
               :
               :/************/
               :
               :  if( ( Angles.z_twist = ( int * ) malloc ( MAX_ROTATIONS * sizeof( int ) ) ) &&
               :      ( Angles.theta   = ( int * ) malloc ( MAX_ROTATIONS * sizeof( int ) ) ) &&
               :      ( Angles.phi     = ( int * ) malloc ( MAX_ROTATIONS * sizeof( int ) ) ) ) {
               :  } else {
               :    GENERAL_MEMORY_PROBLEM
               :  }
               :
               :/************/
               :
               :  n = 0 ;
               :
               :  if( angle_range != 0 ) angle_range = angle_step * (int)( angle_range / angle_step ) ;
               :
               :/************/
               :
               :  phi_step_for_this_theta = 57.29578 * acos( ( cos( 0.017453293 * angle_step ) - ( cos( 0.017453293 * theta ) * cos( 0.017453293 * theta ) ) ) / ( sin( 0.017453293 * theta ) * sin( 0.017453293 * theta ) ) ) ;
               :
               :  while( ( 360 % phi_step_for_this_theta ) != 0 ) phi_step_for_this_theta -- ;
               :
               :/************/
               :
               :  for( z_twist_step = z_twist - angle_range ; z_twist_step <= z_twist + angle_range ; z_twist_step += angle_step ) {
               :
               :    this_z_twist_step = z_twist_step ;
               :
               :    if( this_z_twist_step >= 360 ) this_z_twist_step -= 360 ;
               :    if( this_z_twist_step < 0 ) this_z_twist_step += 360 ;
               :
               :    n ++ ;
               :
               :    Angles.z_twist[n] = this_z_twist_step ;
               :    Angles.theta[n]   = theta ;
               :    Angles.phi[n]     = phi ;
               :
               :  }
               :
               :  for( theta_step = max( theta - angle_range , 0 ) ; theta_step <= min( theta + angle_range , 180 ) ; theta_step += angle_step ) {
               :
               :    if( theta_step != theta ) {
               :
               :      n ++ ;
               :
               :      Angles.z_twist[n] = z_twist ;
               :      Angles.theta[n]   = theta_step ;
               :      Angles.phi[n]     = phi ;
               :
               :    }
               :
               :  }
               :
               :  for( phi_step = phi - angle_range ; phi_step <= phi + angle_range ; phi_step += angle_step ) {
               :
               :    if( phi_step != phi ) {
               :
               :      this_phi_step = phi_step ;
               :
               :      if( this_phi_step >= 360 ) this_phi_step -= 360 ;
               :      if( this_phi_step < 0 ) this_phi_step += 360 ;
               :
               :      n ++ ;
               :
               :      Angles.z_twist[n] = z_twist ;
               :      Angles.theta[n]   = theta ;
               :      Angles.phi[n]     = this_phi_step ;
               :
               :    }
               :
               :  }
               :
               :/************/
               :
               :  if( ( Angles.z_twist = ( int * ) realloc ( Angles.z_twist  , ( 1 + n ) * sizeof( int ) ) ) &&
               :      ( Angles.theta   = ( int * ) realloc ( Angles.theta    , ( 1 + n ) * sizeof( int ) ) ) &&
               :      ( Angles.phi     = ( int * ) realloc ( Angles.phi      , ( 1 + n ) * sizeof( int ) ) ) ) {
               :  } else {
               :    GENERAL_MEMORY_PROBLEM
               :  }
               :
               :  Angles.n = n ;
               :
               :/************/
               :
               :  return Angles ;
               :
               :}
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/string/../sysdeps/i386/i586/strcpy.S"
 * 
 *      1 1.1e-04
 */


 /* strcpy total:      1 1.1e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/stdlib/strtol.c"
 * 
 *      1 1.1e-04
 */


 /* __strtol_internal total:      1 1.1e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/stdio-common/isoc99_sscanf.c"
 * 
 *      1 1.1e-04
 */


 /* __isoc99_sscanf total:      1 1.1e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/stdio-common/fprintf.c"
 * 
 *      1 1.1e-04
 */


 /* fprintf total:      1 1.1e-04 */
