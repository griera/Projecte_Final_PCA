/* 
 * Command line: opannotate --source ./ftdock 
 * 
 * Interpretation of command line:
 * Output annotated source file with samples
 * Output all files
 * 
 * CPU: Core 2, speed 3e+06 MHz (estimated)
 * Counted L1D_REPL events (Cache lines allocated in the L1 data cache) with a unit mask of 0x0f (No unit mask) count 5000
 */
/* 
 * Total samples for file : "/home2/users/alumnes/1125822/dades/linux/PCA/ProjecteFinal/finalProject1213q2/sources/3D_Dock/progs/electrostatics.c"
 * 
 * 680409 99.8554
 */


               :/*
               :This file is part of ftdock, a program for rigid-body protein-protein docking 
               :Copyright (C) 1997-2000 Gidon Moont
               :
               :Biomolecular Modelling Laboratory
               :Imperial Cancer Research Fund
               :44 Lincoln's Inn Fields
               :London WC2A 3PX
               :
               :+44 (0)20 7269 3348
               :http://www.bmm.icnet.uk/
               :
               :This program is free software; you can redistribute it and/or
               :modify it under the terms of the GNU General Public License
               :as published by the Free Software Foundation; either version 2
               :of the License, or (at your option) any later version.
               :
               :This program is distributed in the hope that it will be useful,
               :but WITHOUT ANY WARRANTY; without even the implied warranty of
               :MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :GNU General Public License for more details.
               :
               :You should have received a copy of the GNU General Public License
               :along with this program; if not, write to the Free Software
               :Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
               :
               :*/
               :
               :#include "structures.h"
               :
               :#define PYTHAGORAS(x1, y1, z1, x2, y2, z2) sqrt( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) + ( ( z1 - z2 ) * ( z1 - z2 ) ) );
               :
               :void assign_charges( struct Structure This_Structure ) { /* assign_charges total:      1 1.5e-04 */
               :
               :/************/
               :
               :  /* Counters */
               :
               :  int	residue , atom ;
               :
               :/************/
               :
               :  for( residue = 1 ; residue <= This_Structure.length ; residue ++ ) {
               :    for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      This_Structure.Residue[residue].Atom[atom].charge = 0.0 ;
               :
               :      /* peptide backbone */
               :
     1 1.5e-04 :      if( strcmp( This_Structure.Residue[residue].Atom[atom].atom_name , " N  " ) == 0 ) {
               :        if( strcmp( This_Structure.Residue[residue].res_name , "PRO" ) == 0 ) {
               :          This_Structure.Residue[residue].Atom[atom].charge = -0.10 ;
               :        } else {
               :          This_Structure.Residue[residue].Atom[atom].charge =  0.55 ;
               :          if( residue == 1 ) This_Structure.Residue[residue].Atom[atom].charge = 1.00 ;
               :        }
               :      }
               :
               :      if( strcmp( This_Structure.Residue[residue].Atom[atom].atom_name , " O  " ) == 0 ) {
               :        This_Structure.Residue[residue].Atom[atom].charge = -0.55 ;
               :        if( residue == This_Structure.length  ) This_Structure.Residue[residue].Atom[atom].charge = -1.00 ;
               :      }
               :
               :      /* charged residues */
               :
               :      if( ( strcmp( This_Structure.Residue[residue].res_name , "ARG" ) == 0 ) && ( strncmp( This_Structure.Residue[residue].Atom[atom].atom_name , " NH" , 3 ) == 0 ) ) This_Structure.Residue[residue].Atom[atom].charge =  0.50 ;
               :      if( ( strcmp( This_Structure.Residue[residue].res_name , "ASP" ) == 0 ) && ( strncmp( This_Structure.Residue[residue].Atom[atom].atom_name , " OD" , 3 ) == 0 ) ) This_Structure.Residue[residue].Atom[atom].charge = -0.50 ;
               :      if( ( strcmp( This_Structure.Residue[residue].res_name , "GLU" ) == 0 ) && ( strncmp( This_Structure.Residue[residue].Atom[atom].atom_name , " OE" , 3 ) == 0 ) ) This_Structure.Residue[residue].Atom[atom].charge = -0.50 ;
               :      if( ( strcmp( This_Structure.Residue[residue].res_name , "LYS" ) == 0 ) && ( strcmp( This_Structure.Residue[residue].Atom[atom].atom_name , " NZ " ) == 0 ) ) This_Structure.Residue[residue].Atom[atom].charge =  1.00 ;
               :
               :    }
               :  }
               :
               :/************/
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
     1 1.5e-04 :void electric_field( struct Structure This_Structure , float grid_span , int grid_size , fftw_real *grid ) { /* electric_field total: 680350 99.8468 */
               :
               :/************/
               :
               :  /* Counters */
               :
               :  int	residue , atom ;
               :
               :  /* Co-ordinates */
               :
               :  int	x , y , z ;
               :  float		x_centre , y_centre , z_centre ;
               :
               :  /* Variables */
               :
               :  float		distance ;
               :  float		phi , epsilon ;
               :
               :/************/
               :
               :  for( x = 0 ; x < grid_size ; x ++ ) {
     2 2.9e-04 :    for( y = 0 ; y < grid_size ; y ++ ) {
     1 1.5e-04 :      for( z = 0 ; z < grid_size ; z ++ ) {
               :
    22  0.0032 :        grid[gaddress(x,y,z,grid_size)] = (fftw_real)0 ;
               :
               :      }
               :    }
               :  }
               :
               :/************/
               :
               :  setvbuf( stdout , (char *)NULL , _IONBF , 0 ) ;
               :
               :  printf( "  electric field calculations ( one dot / grid sheet ) " ) ;
               :
               :  for( x = 0 ; x < grid_size ; x ++ ) {
               :
               :    printf( "." ) ;
               :
               :    x_centre  = gcentre( x , grid_span , grid_size ) ;
               :
     3 4.4e-04 :    for( y = 0 ; y < grid_size ; y ++ ) {
               :
               :      y_centre  = gcentre( y , grid_span , grid_size ) ;
               :
    24  0.0035 :      for( z = 0 ; z < grid_size ; z ++ ) {
               :
   209  0.0307 :        z_centre  = gcentre( z , grid_span , grid_size ) ;
               :
               :        phi = 0 ;
               :
101916 14.9570 :        for( residue = 1 ; residue <= This_Structure.length ; residue ++ ) {
146982 21.5708 :          for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom ++ ) {
               :
154512 22.6759 :            if( This_Structure.Residue[residue].Atom[atom].charge != 0 ) {
               :
235091 34.5015 :              distance = PYTHAGORAS( This_Structure.Residue[residue].Atom[atom].coord[1] , This_Structure.Residue[residue].Atom[atom].coord[2] , This_Structure.Residue[residue].Atom[atom].coord[3] , x_centre , y_centre , z_centre ) ;
               :         
               :              if( distance < 2.0 ) distance = 2.0 ;
               :
 35814  5.2560 :              if (distance < 8) { 
               :
   100  0.0147 :                if( distance <= 6.0 ) { 
               :
  4422  0.6490 :                  epsilon = 4 ;
               :             
               :                } else {
               :
   208  0.0305 :                  epsilon = ( 38 * distance ) - 224 ;
               :
               :                }
               :  
   753  0.1105 :                phi += ( This_Structure.Residue[residue].Atom[atom].charge / ( epsilon * distance ) ) ;
               :
               :              }
               :
               :            }
               :
               :          }
               :        }
               :
   290  0.0426 :        grid[gaddress(x,y,z,grid_size)] = (fftw_real)phi ;
               :
               :      }
               :    }
               :  }
               :
               :  printf( "\n" ) ;
               :
               :/************/
               :
               :  return ;
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :void electric_point_charge( struct Structure This_Structure , float grid_span , int grid_size , fftw_real *grid ) { /* electric_point_charge total:     27  0.0040 */
               :
               :/************/
               :
               :  /* Counters */
               :
               :  int	residue , atom ;
               :
               :  /* Co-ordinates */
               :
               :  int	x , y , z ;
               :  int	x_low , x_high , y_low , y_high , z_low , z_high ;
               :
               :  float		a , b , c ;
               :  float		x_corner , y_corner , z_corner ;
               :  float		w ;
               :
               :  /* Variables */
               :
               :  float		one_span ;
               :
               :/************/
               :
     2 2.9e-04 :  for( x = 0 ; x < grid_size ; x ++ ) {
     5 7.3e-04 :    for( y = 0 ; y < grid_size ; y ++ ) {
               :      for( z = 0 ; z < grid_size ; z ++ ) {
               :
    20  0.0029 :        grid[gaddress(x,y,z,grid_size)] = (fftw_real)0 ;
               :
               :      }
               :    }
               :  }
               :
               :/************/
               :
               :  one_span = grid_span / (float)grid_size ;
               :
               :  for( residue = 1 ; residue <= This_Structure.length ; residue ++ ) {
               :    for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      if( This_Structure.Residue[residue].Atom[atom].charge != 0 ) {
               :
               :        x_low = gord( This_Structure.Residue[residue].Atom[atom].coord[1] - ( one_span / 2 ) , grid_span , grid_size ) ;
               :        y_low = gord( This_Structure.Residue[residue].Atom[atom].coord[2] - ( one_span / 2 ) , grid_span , grid_size ) ;
               :        z_low = gord( This_Structure.Residue[residue].Atom[atom].coord[3] - ( one_span / 2 ) , grid_span , grid_size ) ;
               :
               :        x_high = x_low + 1 ;
               :        y_high = y_low + 1 ;
               :        z_high = z_low + 1 ;
               :
               :        a = This_Structure.Residue[residue].Atom[atom].coord[1] - gcentre( x_low , grid_span , grid_size ) - ( one_span / 2 ) ;
               :        b = This_Structure.Residue[residue].Atom[atom].coord[2] - gcentre( y_low , grid_span , grid_size ) - ( one_span / 2 ) ;
               :        c = This_Structure.Residue[residue].Atom[atom].coord[3] - gcentre( z_low , grid_span , grid_size ) - ( one_span / 2 ) ;
               :
               :        for( x = x_low ; x <= x_high  ; x ++ ) {
               : 
               :          x_corner = one_span * ( (float)( x - x_high ) + .5 ) ;
               :
               :          for( y = y_low ; y <= y_high  ; y ++ ) {
               :
               :            y_corner = one_span * ( (float)( y - y_high ) + .5 ) ;
               :
               :            for( z = z_low ; z <= z_high  ; z ++ ) {
               :
               :              z_corner = one_span * ( (float)( z - z_high ) + .5 ) ;
               :
               :              w = ( ( x_corner + a ) * ( y_corner + b ) * ( z_corner + c ) ) / ( 8.0 * x_corner * y_corner * z_corner ) ;
               :
               :              grid[gaddress(x,y,z,grid_size)] += (fftw_real)( w * This_Structure.Residue[residue].Atom[atom].charge ) ;
               :
               :            }
               :          }
               :        }
               :
               :      }
               :
               :    }
               :  }
               :
               :/************/
               :
               :  return ;
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :void electric_field_zero_core( int grid_size , fftw_real *elec_grid , fftw_real *surface_grid , float internal_value ) { /* electric_field_zero_core total:     31  0.0045 */
               :
               :/************/
               :
               :  /* Co-ordinates */
               :
               :  int	x , y , z ;
               :
               :/************/
               :
               :  for( x = 0 ; x < grid_size ; x ++ ) {
     3 4.4e-04 :    for( y = 0 ; y < grid_size ; y ++ ) {
    11  0.0016 :      for( z = 0 ; z < grid_size ; z ++ ) {
               :
    17  0.0025 :        if( surface_grid[gaddress(x,y,z,grid_size)] == (fftw_real)internal_value ) elec_grid[gaddress(x,y,z,grid_size)] = (fftw_real)0 ;
               :
               :      }
               :    }
               :  }
               :
               :/************/
               :
               :  return ;
               :
               :}
/* 
 * Total samples for file : "/home2/users/alumnes/1125822/dades/linux/PCA/ProjecteFinal/finalProject1213q2/sources/3D_Dock/progs/ftdock.c"
 * 
 *    232  0.0340
 */


               :/*
               :This file is part of ftdock, a program for rigid-body protein-protein docking 
               :Copyright (C) 1997-2000 Gidon Moont
               :
               :Biomolecular Modelling Laboratory
               :Imperial Cancer Research Fund
               :44 Lincoln's Inn Fields
               :London WC2A 3PX
               :
               :+44 (0)20 7269 3348
               :http://www.bmm.icnet.uk/
               :
               :This program is free software; you can redistribute it and/or
               :modify it under the terms of the GNU General Public License
               :as published by the Free Software Foundation; either version 2
               :of the License, or (at your option) any later version.
               :
               :This program is distributed in the hope that it will be useful,
               :but WITHOUT ANY WARRANTY; without even the implied warranty of
               :MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :GNU General Public License for more details.
               :
               :You should have received a copy of the GNU General Public License
               :along with this program; if not, write to the Free Software
               :Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
               :
               :*/
               :
               :#include "structures.h"
               :#include <sys/time.h>
               :#include <sys/resource.h>
               :
               :
               :void print_electric_grid ( fftw_real *grid, int grid_size)
               :{
               :  int i, diff;
               :
               :  for (i=0; i<(grid_size * grid_size * ( 2 * ( grid_size / 2 + 1 ) ) * sizeof( fftw_real ))-3; i+=4) 
               :       write (1, (void *)((char *)grid+i), sizeof(int));  
               :  if ((diff=i-(grid_size * grid_size * ( 2 * ( grid_size / 2 + 1 ) ) * sizeof( fftw_real )))>0)
               :       write(1,(void *)((char *)grid+i),diff);
               :
               :}
               :
     8  0.0012 :int main( int argc , char *argv[] ) { /* main total:    232  0.0340 */
               :
               :  /* index counters */
               :
               :  int	i ;
               :
               :  /* Command line options */
               :
               :  char		*output_file_name ;
               :  char		*static_file_name ;
               :  char		*mobile_file_name ;
               :  int		global_grid_size ;
               :  int		angle_step ;
               :  float		surface ;
               :  float		internal_value ;
               :  int		electrostatics ;
               :  int		keep_per_rotation ;
               :  int 		kept_scores ;
               :  int		rescue ;
               :  int		calculate ;
               :  float		reverse_calculated_one_span ;
               :
               :  char		*default_global_grid_size ;
               :  char		*default_angle_step ;
               :  char		*default_surface ;
               :  char		*default_internal_value ;
               :  char		*default_electrostatics ;
               :  char		*default_keep_per_rotation ;
               :
               :  /* File stuff */
               :
               :  FILE		*ftdock_file ;
               :  char		line_buffer[100] ;
               :  int		id , id2 , SCscore ;
               :  float		RPscore ;
               :  int		x , y , z , z_twist , theta , phi ;
               :
               :  /* Angles stuff */
               :
               :  struct Angle	Angles ;
               :  int		first_rotation , rotation ;
               :
               :  /* Structures */
               :
               :  struct Structure	Static_Structure , Mobile_Structure ;
               :  struct Structure	Origin_Static_Structure , Origin_Mobile_Structure ;
               :  struct Structure	Rotated_at_Origin_Mobile_Structure ;
               :
               :  /* Co-ordinates */
               :
               :  int		xyz , fx , fy , fz , fxyz ;
               :
               :  /* Grid stuff */
               :
               :  float		grid_span , one_span ;
               :
               :  fftw_real	*static_grid ;
               :  fftw_real	*mobile_grid ;
               :  fftw_real	*convoluted_grid ;
               :
               :  fftw_real	*static_elec_grid = ( void * ) 0 ;
               :  fftw_real	*mobile_elec_grid = ( void * ) 0 ;
               :  fftw_real	*convoluted_elec_grid = ( void * ) 0 ;
               :
               :  /* FFTW stuff */
               :
               :  rfftwnd_plan	p , pinv ;
               :
               :  fftw_complex  *static_fsg ;
               :  fftw_complex  *mobile_fsg ;
               :  fftw_complex  *multiple_fsg ;
               :
               :  fftw_complex  *static_elec_fsg = ( void * ) 0 ;
               :  fftw_complex  *mobile_elec_fsg = ( void * ) 0 ;
               :  fftw_complex  *multiple_elec_fsg = ( void * ) 0 ;
               :
               :  /* Scores */
               :
               :  struct Score	*Scores ;
               :  float		max_es_value ;
               :
               :/************/
               :
               :  /* Its nice to tell people what going on straight away */
               :
               :  setvbuf( stdout , (char *)NULL , _IONBF , 0 ) ;
               :
               :
               :  printf( "\n          3D-Dock Suite (March 2001)\n" ) ;
               :  printf( "          Copyright (C) 1997-2000 Gidon Moont\n" ) ;
               :  printf( "          This program comes with ABSOLUTELY NO WARRANTY\n" ) ;
               :  printf( "          for details see license. This program is free software,\n"); 
               :  printf( "          and you may redistribute it under certain conditions.\n\n"); 
               :
               :  printf( "          Biomolecular Modelling Laboratory\n" ) ;
               :  printf( "          Imperial Cancer Research Fund\n" ) ;
               :  printf( "          44 Lincoln's Inn Fields\n" ) ;
               :  printf( "          London WC2A 3PX\n" ) ;
               :  printf( "          +44 (0)20 7269 3348\n" ) ;
               :  printf( "          http://www.bmm.icnet.uk/\n\n" ) ;
               :
               :
               :  printf( "Starting FTDock (v2.0) global search program\n" ) ;
               :
               :
               :/************/
               :
               :  /* Memory allocation */
               :
               :  if( ( ( output_file_name  = ( char * ) malloc ( 500 * sizeof( char ) ) ) == NULL ) ||
               :      ( ( static_file_name  = ( char * ) malloc ( 500 * sizeof( char ) ) ) == NULL ) ||
               :      ( ( mobile_file_name  = ( char * ) malloc ( 500 * sizeof( char ) ) ) == NULL ) ) {
               :    GENERAL_MEMORY_PROBLEM 
               :  }
               :
               :/************/
               :
               :  /* Command Line defaults */
               :
               :  strcpy( output_file_name , "ftdock_global.dat" ) ;
               :  strcpy( static_file_name , " --static file name was not provided--" ) ;
               :  strcpy( mobile_file_name , " --mobile file name was not provided--" ) ;
               :  global_grid_size = 128 ;
               :  angle_step = 12 ;
               :  surface = 1.3 ;
               :  internal_value = -15 ;
               :  electrostatics = 1 ;
               :  keep_per_rotation = 3 ;
               :  rescue = 0 ;
               :  calculate = 1 ;
               :  reverse_calculated_one_span = 0.7 ;
               :
               :  default_global_grid_size = "(default calculated)" ;
               :  default_angle_step = "(default)" ;
               :  default_surface = "(default)" ;
               :  default_internal_value = "(default)" ;
               :  default_electrostatics = "(default)" ;
               :  default_keep_per_rotation = "(default)" ;
               :
               :  /* Command Line parse */
               :
               :  for( i = 1 ; i < argc ; i ++ ) {
               :
               :    if( strcmp( argv[i] , "-out" ) == 0 ) {
               :      i ++ ;
               :      if( ( i == argc ) || ( strncmp( argv[i] , "-" , 1 ) == 0 ) ) {
               :        printf( "Bad command line\n" ) ;
               :        exit( EXIT_FAILURE ) ;
               :      }
               :      strcpy( output_file_name , argv[i] ) ;
               :    } else {
               :      if( strcmp( argv[i] , "-static" ) == 0 ) {
               :        i ++ ;
               :        if( ( i == argc ) || ( strncmp( argv[i] , "-" , 1 ) == 0 ) ) {
               :          printf( "Bad command line\n" ) ;
               :          exit( EXIT_FAILURE ) ;
               :        }
               :        strcpy( static_file_name , argv[i] ) ;
               :      } else {
               :        if( strcmp( argv[i] , "-mobile" ) == 0 ) {
               :          i ++ ;
               :          if( ( i == argc ) || ( strncmp( argv[i] , "-" , 1 ) == 0 ) ) {
               :            printf( "Bad command line\n" ) ;
               :            exit( EXIT_FAILURE ) ;
               :          }
               :          strcpy( mobile_file_name , argv[i] ) ;
               :        } else {
               :          if( strcmp( argv[i] , "-grid" ) == 0 ) {
               :            i ++ ;
               :            if( ( i == argc ) || ( strncmp( argv[i] , "-" , 1 ) == 0 ) ) {
               :              printf( "Bad command line\n" ) ;
               :              exit( EXIT_FAILURE ) ;
               :            }
               :            sscanf( argv[i] , "%d" , &global_grid_size ) ;
               :            if( ( global_grid_size % 2 ) != 0 ) {
               :              printf( "Grid size must be even\n" ) ;
               :              exit( EXIT_FAILURE ) ;
               :            }
               :            default_global_grid_size = "(user defined)" ;
               :            calculate = 0 ;
               :          } else {
               :            if( strcmp( argv[i] , "-angle_step" ) == 0 ) {
               :              i ++ ;
               :              if( ( i == argc ) || ( strncmp( argv[i] , "-" , 1 ) == 0 ) ) {
               :                printf( "Bad command line\n" ) ;
               :                exit( EXIT_FAILURE ) ;
               :              }
               :              sscanf( argv[i] , "%d" , &angle_step ) ;
               :              default_angle_step = "(user defined)" ;
               :            } else {
               :              if( strcmp( argv[i] , "-surface" ) == 0 ) {
               :                i ++ ;
               :                if( ( i == argc ) || ( strncmp( argv[i] , "-" , 1 ) == 0 ) ) {
               :                  printf( "Bad command line\n" ) ;
               :                  exit( EXIT_FAILURE ) ;
               :                }
               :                sscanf( argv[i] , "%f" , &surface ) ;
               :                default_surface = "(user defined)" ;
               :              } else {
               :                if( strcmp( argv[i] , "-internal" ) == 0 ) {
               :                  i ++ ;
               :                  if( i == argc ) {
               :                    printf( "Bad command line\n" ) ;
               :                    exit( EXIT_FAILURE ) ;
               :                  }
               :                  sscanf( argv[i] , "%f" , &internal_value ) ;
               :                  default_internal_value = "(user defined)" ;
               :                } else {
               :                  if( strcmp( argv[i] , "-noelec" ) == 0 ) {
               :                    electrostatics = 0 ;
               :                    default_electrostatics = "(user defined)" ;
               :                  } else {
               :                    if( strcmp( argv[i] , "-keep" ) == 0 ) {
               :                      i ++ ;
               :                      if( ( i == argc ) || ( strncmp( argv[i] , "-" , 1 ) == 0 ) ) {
               :                        printf( "Bad command line\n" ) ;
               :                        exit( EXIT_FAILURE ) ;
               :                      }
               :                      sscanf( argv[i] , "%d" , &keep_per_rotation ) ;
               :                      default_keep_per_rotation = "(user defined)" ;
               :                    } else {
               :                      if( strcmp( argv[i] , "-rescue" ) == 0 ) {
               :                        rescue = 1 ;
               :                      } else {
               :                        if( strcmp( argv[i] , "-calculate_grid" ) == 0 ) {
               :                          i ++ ;
               :                          if( ( i == argc ) || ( strncmp( argv[i] , "-" , 1 ) == 0 ) ) {
               :                            printf( "Bad command line\n" ) ;
               :                            exit( EXIT_FAILURE ) ;
               :                          }
               :                          calculate = 1 ;
               :                          default_global_grid_size = "(user defined calculated)" ;
               :                          sscanf( argv[i] , "%f" , &reverse_calculated_one_span ) ;
               :                        } else {
               :                          printf( "Bad command line\n" ) ;
               :                          exit( EXIT_FAILURE ) ;
               :                        }
               :                      }
               :                    }
               :                  }
               :                }
               :              }
               :            }
               :          }
               :        }
               :      }
               :    }
               :
               :  }
               :
               :/************/
               :
               :  /* Rescue option */
               :
               :  if( rescue == 1 ) {
               :
               :    printf( "RESCUE mode\n" ) ;
               :
               :    if( ( ftdock_file = fopen( "scratch_parameters.dat" , "r" ) ) == NULL ) {
               :      printf( "Could not open scratch_parameters.dat for reading.\nDying\n\n" ) ;
               :      exit( EXIT_FAILURE ) ;
               :    }
               :
               :    calculate = 0 ;
               :
               :    default_global_grid_size = "(read from rescue file)" ;
               :    default_angle_step = "(read from rescue file)" ;
               :    default_surface = "(read from rescue file)" ;
               :    default_internal_value = "(read from rescue file)" ;
               :    default_electrostatics = "(read from rescue file)" ;
               :
               :    while( fgets( line_buffer , 99 , ftdock_file ) ) {
               :
               :      if( strncmp( line_buffer , "Static molecule" , 15 ) == 0 ) sscanf( line_buffer , "Static molecule :: %s" , static_file_name ) ;
               :      if( strncmp( line_buffer , "Mobile molecule" , 15 ) == 0 ) sscanf( line_buffer , "Mobile molecule :: %s" , mobile_file_name ) ;
               :      if( strncmp( line_buffer , "Output file name" , 16 ) == 0 ) sscanf( line_buffer , "Output file name :: %s" , output_file_name ) ;
               :      if( strncmp( line_buffer , "Global grid size" , 16 ) == 0 ) sscanf( line_buffer , "Global grid size :: %d" , &global_grid_size ) ;
               :      if( strncmp( line_buffer , "Global search angle step" , 24 ) == 0 ) sscanf( line_buffer , "Global search angle step :: %d" , &angle_step ) ;
               :      if( strncmp( line_buffer , "Global surface thickness" , 24 ) == 0 ) sscanf( line_buffer , "Global surface thickness :: %f" , &surface ) ;
               :      if( strncmp( line_buffer , "Global internal deterrent value" , 31 ) == 0 ) sscanf( line_buffer , "Global internal deterrent value :: %f" , &internal_value ) ;
               :      if( strncmp( line_buffer , "Electrostatics                     ::     on" , 44 ) == 0 ) electrostatics = 1 ;    
               :      if( strncmp( line_buffer , "Electrostatics                     ::    off" , 44 ) == 0 ) electrostatics = 0 ;    
               :      if( strncmp( line_buffer , "Global keep per rotation" , 25 ) == 0 ) sscanf( line_buffer , "Global keep per rotation :: %d" , &keep_per_rotation ) ;
               :
               :    }
               :
               :    fclose( ftdock_file ) ;
               :
               :    if( ( ftdock_file = fopen( "scratch_scores.dat" , "r" ) ) == NULL ) {
               :      printf( "Could not open scratch_scores.dat for reading.\nDying\n\n" ) ;
               :      exit( EXIT_FAILURE ) ;
               :    }
               :
               :    fgets( line_buffer , 99 , ftdock_file ) ;
               :
               :    while( fgets( line_buffer , 99 , ftdock_file ) ) {
               :
               :      sscanf( line_buffer , "G_DATA %d " , &first_rotation ) ;
               :
               :    }
               :
               :    fclose( ftdock_file ) ;
               :
               :    first_rotation ++ ;
               :
               :    printf( "Will be starting from rotation %d\n" , first_rotation ) ;
               :
               :/************/
               :
               :  } else {
               :
               :    first_rotation = 1 ;
               :
               :  }
               :  printf( "PCA TIMING SHOULD start here\n");
               :
               :  struct rusage usage;
               :  struct timeval start_utime, end_utime, start_stime, end_stime;
               :    
               :  if (getrusage(RUSAGE_SELF, &usage) == -1) exit(0);
               :  start_utime = usage.ru_utime;
               :  start_stime = usage.ru_stime;
               :
               :/************/
               :
               :  /* Do these things first so that bad inputs will be caught soonest */
               :
               :  /* Read in Structures from pdb files */
               :  Static_Structure = read_pdb_to_structure( static_file_name ) ;
               :  Mobile_Structure = read_pdb_to_structure( mobile_file_name ) ;
               :
               :  if( Mobile_Structure.length > Static_Structure.length ) {
               :    printf( "WARNING\n" ) ;
               :    printf( "The mobile molecule has more residues than the static\n" ) ;
               :    printf( "Are you sure you have the correct molecules?\n" ) ;
               :    printf( "Continuing anyway\n" ) ;
               :  }
               :  
               :/************/
               :
               :  /* Get angles */
               :  Angles = generate_global_angles( angle_step ) ;
               :
               :  printf( "Total number of rotations is %d\n" , Angles.n ) ;
               :
               :/************/
               :
               :  /* Assign charges */
               :
               :  if( electrostatics == 1 ) {
               :    printf( "Assigning charges\n" ) ;
               :    assign_charges( Static_Structure ) ;
               :    assign_charges( Mobile_Structure ) ;
               :  }
               :
               :/************/
               :
               :  /* Store new structures centered on Origin */
               :
               :  Origin_Static_Structure = translate_structure_onto_origin( Static_Structure ) ;
               :  Origin_Mobile_Structure = translate_structure_onto_origin( Mobile_Structure ) ;
               :
               :  /* Free some memory */
               :
               :  for( i = 1 ; i <= Static_Structure.length ; i ++ ) {
               :    free( Static_Structure.Residue[i].Atom ) ;
               :  }
               :  free( Static_Structure.Residue ) ;
               :
               :  for( i = 1 ; i <= Mobile_Structure.length ; i ++ ) {
               :    free( Mobile_Structure.Residue[i].Atom ) ;
               :  }
               :  free( Mobile_Structure.Residue ) ;
               :
               :/************/
               :
               :  /* Calculate Grid stuff */
               :
               :  grid_span = total_span_of_structures( Origin_Static_Structure , Origin_Mobile_Structure ) ;
               :
               :  if( calculate == 1 ) {
               :    printf( "Using automatic calculation for grid size\n" ) ;
               :    global_grid_size = (int)( grid_span / reverse_calculated_one_span ) ;
               :    if( ( global_grid_size % 2 ) != 0 ) global_grid_size ++ ;
               :  }
               :
               :  one_span = grid_span / (float)global_grid_size ;
               :
               :  printf( "Span = %.3f angstroms\n" , grid_span ) ;
               :  printf( "Grid size = %d\n" , global_grid_size ) ;
               :  printf( "Each Grid cube = %.5f angstroms\n" , one_span ) ;
               :
               :/************/
               :
               :  /* Memory Allocation */
               :
               :  if( ( Scores = ( struct Score * ) malloc ( ( keep_per_rotation + 2 ) * sizeof( struct Score ) ) ) == NULL ) {
               :    GENERAL_MEMORY_PROBLEM
               :  }
               :
               :  if(
               :    ( ( static_grid = ( fftw_real * ) malloc
               :     ( global_grid_size * global_grid_size * ( 2 * ( global_grid_size / 2 + 1 ) ) * sizeof( fftw_real ) ) ) == NULL )
               :    ||
               :    ( ( mobile_grid = ( fftw_real * ) malloc
               :     ( global_grid_size * global_grid_size * ( 2 * ( global_grid_size / 2 + 1 ) ) * sizeof( fftw_real ) ) ) == NULL )
               :    ||
               :    ( ( convoluted_grid = ( fftw_real * ) malloc
               :     ( global_grid_size * global_grid_size * ( 2 * ( global_grid_size / 2 + 1 ) ) * sizeof( fftw_real ) ) ) == NULL )
               :    ) {
               :    printf( "Not enough memory for surface grids\nUse (sensible) smaller grid size\nDying\n\n" ) ;
               :    exit( EXIT_FAILURE ) ;
               :  }
               :
               :  static_fsg = ( fftw_complex * ) static_grid ;
               :  mobile_fsg = ( fftw_complex * ) mobile_grid ;
               :  multiple_fsg = ( fftw_complex * ) convoluted_grid ;
               :
               :  if( electrostatics == 1 ) {
               :
               :    if(
               :      ( ( static_elec_grid = ( fftw_real * ) malloc
               :       ( global_grid_size * global_grid_size * ( 2 * ( global_grid_size / 2 + 1 ) ) * sizeof( fftw_real ) ) ) == NULL )
               :      ||
               :      ( ( mobile_elec_grid = ( fftw_real * ) malloc
               :       ( global_grid_size * global_grid_size * ( 2 * ( global_grid_size / 2 + 1 ) ) * sizeof( fftw_real ) ) ) == NULL )
               :      ||
               :      ( ( convoluted_elec_grid = ( fftw_real * ) malloc
               :       ( global_grid_size * global_grid_size * ( 2 * ( global_grid_size / 2 + 1 ) ) * sizeof( fftw_real ) ) ) == NULL )
               :      ) {
               :      printf( "Not enough memory for electrostatic grids\nSwitch off electrostatics or use (sensible) smaller grid size\nDying\n\n" ) ;
               :      exit( EXIT_FAILURE ) ;
               :    } else {
               :      /* all ok */
               :      printf( "Electrostatics are on\n" ) ;
               :    }
               :
               :    static_elec_fsg = ( fftw_complex * ) static_elec_grid ;
               :    mobile_elec_fsg = ( fftw_complex * ) mobile_elec_grid ;
               :    multiple_elec_fsg = ( fftw_complex * ) convoluted_elec_grid ;
               :
               :  }
               :
               :/************/
               :
               :  /* Create FFTW plans */
               :
               :  printf( "Creating plans\n" ) ;
               :  p    = rfftw3d_create_plan( global_grid_size , global_grid_size , global_grid_size ,
               :                               FFTW_REAL_TO_COMPLEX , FFTW_MEASURE | FFTW_IN_PLACE ) ;
               :  pinv = rfftw3d_create_plan( global_grid_size , global_grid_size , global_grid_size ,
               :                               FFTW_COMPLEX_TO_REAL , FFTW_MEASURE | FFTW_IN_PLACE ) ;
               :
               :/************/
               :
               :  printf( "Setting up Static Structure\n" ) ;
               :
               :  /* Discretise and surface the Static Structure (need do only once) */
               :  discretise_structure( Origin_Static_Structure , grid_span , global_grid_size , static_grid ) ;
               :  printf( "  surfacing grid\n" ) ;
               :  surface_grid( grid_span , global_grid_size , static_grid , surface , internal_value ) ;
               :
               :  /* Calculate electic field at all grid nodes (need do only once) */
               :  if( electrostatics == 1 ) {
               :    electric_field( Origin_Static_Structure , grid_span , global_grid_size , static_elec_grid ) ;
               :    electric_field_zero_core( global_grid_size , static_elec_grid , static_grid , internal_value ) ;
               :  }
               :
               :  /* Fourier Transform the static grids (need do only once) */
               :  printf( "  one time forward FFT calculations\n" ) ;
               :  rfftwnd_one_real_to_complex( p , static_grid , NULL ) ;
               :  if( electrostatics == 1 ) {
               :    rfftwnd_one_real_to_complex( p , static_elec_grid , NULL ) ;
               :  }
               :
               :  printf( "  done\n" ) ;
               :
               :/************/
               :
               :  /* Store paramaters in case of rescue */
               :
               :  if( ( ftdock_file = fopen( "scratch_parameters.dat" , "w" ) ) == NULL ) {
               :    printf( "Could not open scratch_parameters.dat for writing.\nDying\n\n" ) ;
               :    exit( EXIT_FAILURE ) ;
               :  }
               :
               :  fprintf( ftdock_file, "\nGlobal Scan\n" ) ;
               :
               :  fprintf( ftdock_file, "\nCommand line controllable values\n" ) ;
               :  fprintf( ftdock_file, "Static molecule                    :: %s\n" , static_file_name ) ;
               :  fprintf( ftdock_file, "Mobile molecule                    :: %s\n" , mobile_file_name ) ;
               :  fprintf( ftdock_file, "Output file name                   :: %s\n" , output_file_name ) ;
               :  fprintf( ftdock_file, "\n" ) ;
               :  fprintf( ftdock_file, "Global grid size                   :: %6d      %s\n" , global_grid_size , default_global_grid_size ) ;
               :  fprintf( ftdock_file, "Global search angle step           :: %6d      %s\n" , angle_step , default_angle_step ) ;
               :  fprintf( ftdock_file, "Global surface thickness           :: %9.2f   %s\n" , surface , default_surface ) ;
               :  fprintf( ftdock_file, "Global internal deterrent value    :: %9.2f   %s\n" , internal_value , default_internal_value ) ;
               :  if( electrostatics == 1 ) {
               :    fprintf( ftdock_file, "Electrostatics                     ::     on      %s\n" , default_electrostatics ) ;
               :  } else {
               :    fprintf( ftdock_file, "Electrostatics                     ::    off      %s\n" , default_electrostatics ) ;
               :  }
               :  fprintf( ftdock_file, "Global keep per rotation           :: %6d      %s\n" , keep_per_rotation , default_keep_per_rotation ) ;
               :
               :  fprintf( ftdock_file, "\nCalculated values\n" ) ;
               :  fprintf( ftdock_file, "Global rotations                   :: %6d\n" , Angles.n ) ;
               :  fprintf( ftdock_file, "Global total span (angstroms)      :: %10.3f\n" , grid_span ) ;
               :  fprintf( ftdock_file, "Global grid cell span (angstroms)  :: %10.3f\n" , one_span ) ;
               :
               :  fclose( ftdock_file ) ;
               :
               :/************/
               :
               :  /* Main program loop */
               :
               :  max_es_value = 0 ;
               :
               :  printf( "Starting main loop through the rotations\n" ) ;
               :  printf( "PCA TIMING SHOULD stop here\n");
               :
               :  if (getrusage(RUSAGE_SELF, &usage) == -1) exit(0);
               :  end_utime = usage.ru_utime;
               :  end_stime = usage.ru_stime;
               :
               :  float utime = ((float)(end_utime.tv_sec) + (float)(end_utime.tv_usec/1000000.0)) - ((float)(start_utime.tv_sec) + (float)(start_utime.tv_usec/1000000.0));
               :
               :  float stime = ((float)(end_stime.tv_sec) + (float)(end_stime.tv_usec/1000000.0)) - ((float)(start_stime.tv_sec) + (float)(start_stime.tv_usec/1000000.0));
               :
               :  printf("\nUser time: %f || System time: %f\nCPU time (user+system): %f\n\n", utime, stime, utime+stime);
               :
               :  /* PCA: start comment
               :     for( rotation = first_rotation ; rotation <= Angles.n ; rotation ++ ) {
               :   * PCA: end comment 
               :   */
               :  for( rotation = first_rotation ; rotation <= 1/*Angles.n*/ ; rotation ++ ) {
               :
               :    printf( "." ) ; 
               :
               :    if( ( rotation % 50 ) == 0 ) printf( "\nRotation number %5d\n" , rotation ) ;
               :
               :    /* Rotate Mobile Structure */
               :    Rotated_at_Origin_Mobile_Structure =
               :     rotate_structure( Origin_Mobile_Structure , (int)Angles.z_twist[rotation] , (int)Angles.theta[rotation] , (int)Angles.phi[rotation] ) ;
               :
               :    /* Discretise the rotated Mobile Structure */
               :    discretise_structure( Rotated_at_Origin_Mobile_Structure , grid_span , global_grid_size , mobile_grid ) ;
               :
               :    /* Electic point charge approximation onto grid calculations ( quicker than filed calculations by a long way! ) */
               :    if( electrostatics == 1 ) {
               :      electric_point_charge( Rotated_at_Origin_Mobile_Structure , grid_span , global_grid_size , mobile_elec_grid ) ;
               :    }
               :
               :    /* Forward Fourier Transforms */
               :    rfftwnd_one_real_to_complex( p , mobile_grid , NULL ) ;
               :    if( electrostatics == 1 ) {
               :      rfftwnd_one_real_to_complex( p , mobile_elec_grid , NULL ) ;
               :    }
               :
               :/************/
               :
               :    /* Do convolution of the two sets of grids
               :       convolution is equivalent to multiplication of the complex conjugate of one
               :       fourier grid with other (raw) one
               :       hence the sign changes from a normal complex number multiplication
               :    */
               :
               :    for( fx = 0 ; fx < global_grid_size ; fx ++ ) {
     1 1.5e-04 :      for( fy = 0 ; fy < global_grid_size ; fy ++ ) {
    38  0.0056 :        for( fz = 0 ; fz < global_grid_size/2 + 1 ; fz ++ ) {
               :
               :          fxyz = fz + ( global_grid_size/2 + 1 ) * ( fy + global_grid_size * fx ) ;
               :
     2 2.9e-04 :          multiple_fsg[fxyz].re =
    40  0.0059 :           static_fsg[fxyz].re * mobile_fsg[fxyz].re + static_fsg[fxyz].im * mobile_fsg[fxyz].im ;
               :          multiple_fsg[fxyz].im =
     8  0.0012 :           static_fsg[fxyz].im * mobile_fsg[fxyz].re - static_fsg[fxyz].re * mobile_fsg[fxyz].im ;
               :           
               :          if( electrostatics == 1 ) {
    14  0.0021 :            multiple_elec_fsg[fxyz].re =
    37  0.0054 :             static_elec_fsg[fxyz].re * mobile_elec_fsg[fxyz].re + static_elec_fsg[fxyz].im * mobile_elec_fsg[fxyz].im ;
     2 2.9e-04 :            multiple_elec_fsg[fxyz].im =
    29  0.0043 :             static_elec_fsg[fxyz].im * mobile_elec_fsg[fxyz].re - static_elec_fsg[fxyz].re * mobile_elec_fsg[fxyz].im ;
               :          }
               :
               :        }
               :      }
               :    }
               :
               :    /* Reverse Fourier Transform */
               :    rfftwnd_one_complex_to_real( pinv , multiple_fsg , NULL ) ;
               :    if( electrostatics == 1 ) {
               :      rfftwnd_one_complex_to_real( pinv , multiple_elec_fsg , NULL ) ;
               :    }
               :
               :/************/
               :
               :    /* Get best scores */
               :
               :    for( i = 0 ; i < keep_per_rotation ; i ++ ) {
               :
               :      Scores[i].score = 0 ;
               :      Scores[i].rpscore = 0.0 ;
               :      Scores[i].coord[1] = 0 ;
               :      Scores[i].coord[2] = 0 ;
               :      Scores[i].coord[3] = 0 ;
               :
               :    }
               :
               :    for( x = 0 ; x < global_grid_size ; x ++ ) {
               :      fx = x ;
               :      if( fx > ( global_grid_size / 2 ) ) fx -= global_grid_size ;
               :
               :      for( y = 0 ; y < global_grid_size ; y ++ ) {
               :        fy = y ;
               :        if( fy > ( global_grid_size / 2 ) ) fy -= global_grid_size ;
               :
     6 8.8e-04 :        for( z = 0 ; z < global_grid_size ; z ++ ) {
               :          fz = z ;
               :          if( fz > ( global_grid_size / 2 ) ) fz -= global_grid_size ;
               :
     2 2.9e-04 :          xyz = z + ( 2 * ( global_grid_size / 2 + 1 ) ) * ( y + global_grid_size * x ) ;
               :
    10  0.0015 :          if( ( electrostatics == 0 ) || ( convoluted_elec_grid[xyz] < 0 ) ) {
               :
               :            /* Scale factor from FFTs */
    15  0.0022 :            if( (int)convoluted_grid[xyz] != 0 ) {
     4 5.9e-04 :              convoluted_grid[xyz] /= ( global_grid_size * global_grid_size * global_grid_size ) ;
               :            }
               :
    16  0.0023 :            if( (int)convoluted_grid[xyz] > Scores[keep_per_rotation-1].score ) {
               :
               :              i = keep_per_rotation - 2 ;
               :
               :              while( ( (int)convoluted_grid[xyz] > Scores[i].score ) && ( i >= 0 ) ) {
               :                Scores[i+1].score    = Scores[i].score ;
               :                Scores[i+1].rpscore  = Scores[i].rpscore ;
               :                Scores[i+1].coord[1] = Scores[i].coord[1] ;
               :                Scores[i+1].coord[2] = Scores[i].coord[2] ;
               :                Scores[i+1].coord[3] = Scores[i].coord[3] ;
               :                i -- ;
               :              }
               :
               :              Scores[i+1].score    = (int)convoluted_grid[xyz] ;
               :              if( ( electrostatics != 0 ) && ( convoluted_elec_grid[xyz] < 0.1 ) ) {
               :                Scores[i+1].rpscore  = (float)convoluted_elec_grid[xyz] ;
               :              } else {
               :                Scores[i+1].rpscore  = (float)0 ;
               :              }
               :              Scores[i+1].coord[1] = fx ;
               :              Scores[i+1].coord[2] = fy ;
               :              Scores[i+1].coord[3] = fz ;
               :
               :            }
               :
               :          }
               :
               :        }
               :      }
               :    }
               :
               :    if( rotation == 1 ) {
               :      if( ( ftdock_file = fopen( "scratch_scores.dat" , "w" ) ) == NULL ) {
               :        printf( "Could not open scratch_scores.dat for writing.\nDying\n\n" ) ;
               :        exit( EXIT_FAILURE ) ;
               :      }
               :    } else {
               :      if( ( ftdock_file = fopen( "scratch_scores.dat" , "a" ) ) == NULL ) {
               :        printf( "Could not open scratch_scores.dat for writing.\nDying\n\n" ) ;
               :        exit( EXIT_FAILURE ) ;
               :      }
               :    }
               :
               :    for( i = 0 ; i < keep_per_rotation ; i ++ ) {
               :
               :      max_es_value = min( max_es_value , Scores[i].rpscore ) ;
               :      /* PCA: start comment
               :
               :      fprintf( ftdock_file, "G_DATA %6d   %6d    %7d       %.0f      %4d %4d %4d      %4d%4d%4d\n" ,
               :                rotation , 0 , Scores[i].score , (double)Scores[i].rpscore , Scores[i].coord[1] , Scores[i].coord[2] , Scores[i].coord[3 ] ,
               :                 Angles.z_twist[rotation] , Angles.theta[rotation]  , Angles.phi[rotation] ) ;
               :
               :       * PCA: Stop comment
               :       */
               :      fprintf( stdout, "G_DATA %6d   %6d    %7d       %4d %4d %4d      %4d%4d%4d\n" ,
               :                rotation , 0 , Scores[i].score , Scores[i].coord[1] , Scores[i].coord[2] , Scores[i].coord[3 ] ,
               :                 Angles.z_twist[rotation] , Angles.theta[rotation]  , Angles.phi[rotation] ) ;
               :
               :    }
               :
               :    fclose( ftdock_file ) ;
               :
               :    /* Free some memory */
               :    for( i = 1 ; i <= Rotated_at_Origin_Mobile_Structure.length ; i ++ ) {
               :      free( Rotated_at_Origin_Mobile_Structure.Residue[i].Atom ) ;
               :    }
               :    free( Rotated_at_Origin_Mobile_Structure.Residue ) ;
               :
               :  }
               :
               :  /* Finished main loop */
               :
               :/************/
               :
               :  /* Free the memory */
               :
               :  rfftwnd_destroy_plan( p ) ;
               :  rfftwnd_destroy_plan( pinv ) ;
               :
               :  free( static_grid ) ;
               :  free( mobile_grid ) ;
               :  free( convoluted_grid ) ;
               :
               :  if( electrostatics == 1 ) {
               :    free( static_elec_grid ) ;
               :    free( mobile_elec_grid ) ;
               :    free( convoluted_elec_grid ) ;
               :  }
               :
               :  for( i = 1 ; i <= Origin_Static_Structure.length ; i ++ ) {
               :    free( Origin_Static_Structure.Residue[i].Atom ) ;
               :  }
               :  free( Origin_Static_Structure.Residue ) ;
               :
               :  for( i = 1 ; i <= Origin_Mobile_Structure.length ; i ++ ) {
               :    free( Origin_Mobile_Structure.Residue[i].Atom ) ;
               :  }
               :  free( Origin_Mobile_Structure.Residue ) ;
               :
               :      /* PCA: Finishing programm here*/ 
               :      printf("PCA STOPS HERE\n");
               :      return 0;
               :      /* PCA: */
               :
               :
               :/************/
               :
               :  /* Read in all the scores */
               :
               :  printf( "\nReloading all the scores\n" ) ;
               :
               :  if( ( ftdock_file = fopen( "scratch_scores.dat" , "r" ) ) == NULL ) {
               :    printf( "Could not open scratch_scores.dat for reading.\nDying\n\n" ) ;
               :    exit( EXIT_FAILURE ) ;
               :  }
               :
               :  if( ( Scores = ( struct Score * ) realloc ( Scores , ( 1 + keep_per_rotation ) * Angles.n * sizeof( struct Score ) ) ) == NULL ) {
               :    printf( "Not enough memory left for storing scores\nProbably keeping too many per rotation\nDying\n\n" ) ;
               :    exit( EXIT_FAILURE ) ;
               :  }
               :
               :  kept_scores = 0 ;
               :
               :  while( fgets( line_buffer , 99 , ftdock_file ) ) {
               :
               :    sscanf( line_buffer , "G_DATA %d %d %d %f  %d %d %d  %d %d %d" , &id , &id2 , &SCscore , &RPscore ,
               :                                                                     &x , &y , &z , &z_twist , &theta , &phi ) ;
               :
               :    Scores[kept_scores].score    = SCscore ;
               :    Scores[kept_scores].rpscore  = RPscore ;
               :    Scores[kept_scores].coord[1] = x ;
               :    Scores[kept_scores].coord[2] = y ;
               :    Scores[kept_scores].coord[3] = z ;
               :    Scores[kept_scores].angle[1] = z_twist ;
               :    Scores[kept_scores].angle[2] = theta ;
               :    Scores[kept_scores].angle[3] = phi ;
               :
               :    kept_scores ++ ;
               :
               :  }
               :
               :  fclose( ftdock_file ) ;
               :
               :  kept_scores -- ;
               :
               :  qsort_scores( Scores , 0 , kept_scores ) ;
               :
               :/************/
               :
               :  /* Writing data file */
               :
               :  if( ( ftdock_file = fopen( output_file_name , "w" ) ) == NULL ) {
               :    printf( "Could not open %s for writing.\nDying\n\n" , output_file_name ) ;
               :    exit( EXIT_FAILURE ) ;
               :  }
               :
               :  fprintf( ftdock_file, "FTDOCK data file\n" ) ;
               :
               :  fprintf( ftdock_file, "\nGlobal Scan\n" ) ;
               :
               :  fprintf( ftdock_file, "\nCommand line controllable values\n" ) ;
               :  fprintf( ftdock_file, "Static molecule                    :: %s\n" , static_file_name ) ;
               :  fprintf( ftdock_file, "Mobile molecule                    :: %s\n" , mobile_file_name ) ;
               :  fprintf( ftdock_file, "\n" ) ;
               :  fprintf( ftdock_file, "Global grid size                   :: %6d      %s\n" , global_grid_size , default_global_grid_size ) ;
               :  fprintf( ftdock_file, "Global search angle step           :: %6d      %s\n" , angle_step , default_angle_step ) ;
               :  fprintf( ftdock_file, "Global surface thickness           :: %9.2f   %s\n" , surface , default_surface ) ;
               :  fprintf( ftdock_file, "Global internal deterrent value    :: %9.2f   %s\n" , internal_value , default_internal_value ) ;
               :  if( electrostatics == 1 ) {
               :    fprintf( ftdock_file, "Electrostatics                     ::     on      %s\n" , default_electrostatics ) ;
               :  } else {
               :    fprintf( ftdock_file, "Electrostatics                     ::    off      %s\n" , default_electrostatics ) ;
               :  }
               :  fprintf( ftdock_file, "Global keep per rotation           :: %6d      %s\n" , keep_per_rotation , default_keep_per_rotation ) ;
               :
               :  fprintf( ftdock_file, "\nCalculated values\n" ) ;
               :  fprintf( ftdock_file, "Global rotations                   :: %6d\n" , Angles.n ) ;
               :  fprintf( ftdock_file, "Global total span (angstroms)      :: %10.3f\n" , grid_span ) ;
               :  fprintf( ftdock_file, "Global grid cell span (angstroms)  :: %10.3f\n" , one_span ) ;
               :
               :  fprintf( ftdock_file, "\nData\n" ) ;
               :  fprintf( ftdock_file , "Type       ID    prvID    SCscore        ESratio         Coordinates            Angles\n\n" ) ;
               :
               :  if( electrostatics == 1 ) {
               :
               :    for( i = 0 ; i <= min( kept_scores , ( NUMBER_TO_KEEP - 1 ) ) ; i ++ ) {
               :
               :      fprintf( ftdock_file, "G_DATA %6d   %6d    %7d       %8.3f      %4d %4d %4d      %4d%4d%4d\n" ,
               :               i + 1 , 0 , Scores[i].score , 100 * ( Scores[i].rpscore / max_es_value ) ,
               :               Scores[i].coord[1] , Scores[i].coord[2] , Scores[i].coord[3] ,
               :               Scores[i].angle[1] , Scores[i].angle[2] , Scores[i].angle[3] ) ;
               :
               :    }
               :
               :  } else {
               :
               :    for( i = 0 ; i <= min( kept_scores , ( NUMBER_TO_KEEP - 1 ) ) ; i ++ ) {
               :
               :      fprintf( ftdock_file, "G_DATA %6d   %6d    %7d       %8.3f      %4d %4d %4d      %4d%4d%4d\n" ,
               :               i + 1 , 0 , Scores[i].score , 0.0 ,
               :               Scores[i].coord[1] , Scores[i].coord[2] , Scores[i].coord[3] ,
               :               Scores[i].angle[1] , Scores[i].angle[2] , Scores[i].angle[3] ) ;
               :
               :    }
               :
               :  }
               :
               :  fclose( ftdock_file ) ;
               :    
               :/************/
               :
               :  printf( "\n\nFinished\n\n" ) ;
               :
               :  return( 0 ) ;
               :
               :} /* end main */
/* 
 * Total samples for file : "/home2/users/alumnes/1125822/dades/linux/PCA/ProjecteFinal/finalProject1213q2/sources/3D_Dock/progs/grid.c"
 * 
 *    107  0.0157
 */


               :/*
               :This file is part of ftdock, a program for rigid-body protein-protein docking 
               :Copyright (C) 1997-2000 Gidon Moont
               :
               :Biomolecular Modelling Laboratory
               :Imperial Cancer Research Fund
               :44 Lincoln's Inn Fields
               :London WC2A 3PX
               :
               :+44 (0)20 7269 3348
               :http://www.bmm.icnet.uk/
               :
               :This program is free software; you can redistribute it and/or
               :modify it under the terms of the GNU General Public License
               :as published by the Free Software Foundation; either version 2
               :of the License, or (at your option) any later version.
               :
               :This program is distributed in the hope that it will be useful,
               :but WITHOUT ANY WARRANTY; without even the implied warranty of
               :MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :GNU General Public License for more details.
               :
               :You should have received a copy of the GNU General Public License
               :along with this program; if not, write to the Free Software
               :Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
               :
               :*/
               :
               :#include "structures.h"
               :
               :void discretise_structure( struct Structure This_Structure , float grid_span , int grid_size , fftw_real *grid ) { /* discretise_structure total:     53  0.0078 */
               :
               :/************/
               :
               :  /* Counters */
               :
               :  int	residue , atom ;
               :
               :  /* Co-ordinates */
               :
               :  int	x , y , z ;
               :  int	steps , x_step , y_step , z_step ;
               :
               :  float		x_centre , y_centre , z_centre ;
               :
               :  /* Variables */
               :
               :  float         distance , one_span ;
               :
               :/************/
               :
               :  one_span = grid_span / (float)grid_size ;
               :
               :  distance = 1.8 ;
               :
               :/************/
               :
     1 1.5e-04 :  for( x = 0 ; x < grid_size ; x ++ ) {
    10  0.0015 :    for( y = 0 ; y < grid_size ; y ++ ) {
     7  0.0010 :      for( z = 0 ; z < grid_size ; z ++ ) {
               :
    35  0.0051 :        grid[gaddress(x,y,z,grid_size)] = (fftw_real)0 ;
               :
               :      }
               :    }
               :  }
               :
               :/************/
               :
               :  steps = (int)( ( distance / one_span ) + 1.5 ) ;
               :
               :  for( residue = 1 ; residue <= This_Structure.length ; residue ++ ) {
               :    for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      x = gord( This_Structure.Residue[residue].Atom[atom].coord[1] , grid_span , grid_size ) ;
               :      y = gord( This_Structure.Residue[residue].Atom[atom].coord[2] , grid_span , grid_size ) ;
               :      z = gord( This_Structure.Residue[residue].Atom[atom].coord[3] , grid_span , grid_size ) ;
               :
               :      for( x_step = max( ( x - steps ) , 0 ) ; x_step <= min( ( x + steps ) , ( grid_size - 1 ) ) ; x_step ++ ) {
               :
               :        x_centre  = gcentre( x_step , grid_span , grid_size ) ;
               :
               :        for( y_step = max( ( y - steps ) , 0 ) ; y_step <= min( ( y + steps ) , ( grid_size - 1 ) ) ; y_step ++ ) {
               :
               :          y_centre  = gcentre( y_step , grid_span , grid_size ) ;
               :
               :          for( z_step = max( ( z - steps ) , 0 ) ; z_step <= min( ( z + steps ) , ( grid_size - 1 ) ) ; z_step ++ ) {
               :
               :            z_centre  = gcentre( z_step , grid_span , grid_size ) ;
               :
               :            if( pythagoras( This_Structure.Residue[residue].Atom[atom].coord[1] , This_Structure.Residue[residue].Atom[atom].coord[2] , This_Structure.Residue[residue].Atom[atom].coord[3] , x_centre , y_centre , z_centre ) < distance ) grid[gaddress(x_step,y_step,z_step,grid_size)] = (fftw_real)1 ;
               :
               :          }
               :        }
               :      }
               :
               :    }
               :  }
               :
               :/************/
               :
               :  return ;
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
     6 8.8e-04 :void surface_grid( float grid_span , int grid_size , fftw_real *grid , float surface , float internal_value ) { /* surface_grid total:     54  0.0079 */
               :
               :
               :/************/
               :
               :  /* Counters */
               :
               :  int	x , y , z ;
               :  int	steps , x_step , y_step , z_step ;
               :
               :  /* Variables */
               :
               :  float		one_span ;
               :
               :  int	at_surface ;
               :
               :/************/
               :
               :  one_span = grid_span / (float)grid_size ;
               :
               :/************/
               :
               :  /* Surface grid atoms */
               :
               :  steps = (int)( ( surface / one_span ) + 1.5 ) ;
               :
               :  for( x = 0 ; x < grid_size ; x ++ ) {
               :    for( y = 0 ; y < grid_size ; y ++ ) {
    14  0.0021 :      for( z = 0 ; z < grid_size ; z ++ ) {
               :
    13  0.0019 :        if( (int)grid[gaddress(x,y,z,grid_size)] == 1 ) {
               :
               :          at_surface = 0 ;
               :
     2 2.9e-04 :          for( x_step = max( x - steps , 0 ) ; x_step <= min( x + steps , grid_size - 1 ) ; x_step ++ ) {
               :            for( y_step = max( y - steps , 0 ) ; y_step <= min( y + steps , grid_size - 1 ) ; y_step ++ ) {
     5 7.3e-04 :              for( z_step = max( z - steps , 0 ) ; z_step <= min( z + steps , grid_size - 1 ) ; z_step ++ ) {
               :
     4 5.9e-04 :                if( (int)grid[gaddress(x_step,y_step,z_step,grid_size)] == 0 ) {
               :
     9  0.0013 :                  if( ( (float)( ( ( x_step - x ) * ( x_step - x ) ) + ( ( y_step - y ) * ( y_step - y ) ) + ( ( z_step - z ) * ( z_step - z ) ) ) * one_span * one_span ) < ( surface * surface ) ) at_surface = 1 ;
               :
               :                }
               :
               :              }
               :            }
               :          }
               :
     1 1.5e-04 :          if( at_surface == 0 ) grid[gaddress(x,y,z,grid_size)] = (fftw_real)internal_value ;
               :
               :        }
               :
               :      }
               :    }
               :  }
               :
               :/************/
               :
               :  return ;
               :
               :}
/* 
 * Total samples for file : "rexec.c"
 * 
 *     67  0.0098
 */

<credited to line zero>     67  0.0098 :
 /* rexecutor_many total:     67  0.0098 */
/* 
 * Total samples for file : "executor.c"
 * 
 *     44  0.0065
 */

<credited to line zero>     44  0.0065 :
 /* executor_many total:     44  0.0065 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/gcc-4.6.2-20111026/obj-i586-suse-linux/i586-suse-linux/libgcc/../../../libgcc/../gcc/libgcc2.c"
 * 
 *      7  0.0010
 */


 /* __moddi3 total:      7  0.0010 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/malloc/malloc.c"
 * 
 *      5 7.3e-04
 */


 /* _int_malloc total:      5 7.3e-04 */
/* 
 * Total samples for file : "/home2/users/alumnes/1125822/dades/linux/PCA/ProjecteFinal/finalProject1213q2/sources/3D_Dock/progs/coordinates.c"
 * 
 *      4 5.9e-04
 */


               :/*
               :This file is part of ftdock, a program for rigid-body protein-protein docking 
               :Copyright (C) 1997-2000 Gidon Moont
               :
               :Biomolecular Modelling Laboratory
               :Imperial Cancer Research Fund
               :44 Lincoln's Inn Fields
               :London WC2A 3PX
               :
               :+44 (0)20 7269 3348
               :http://www.bmm.icnet.uk/
               :
               :This program is free software; you can redistribute it and/or
               :modify it under the terms of the GNU General Public License
               :as published by the Free Software Foundation; either version 2
               :of the License, or (at your option) any later version.
               :
               :This program is distributed in the hope that it will be useful,
               :but WITHOUT ANY WARRANTY; without even the implied warranty of
               :MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :GNU General Public License for more details.
               :
               :You should have received a copy of the GNU General Public License
               :along with this program; if not, write to the Free Software
               :Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
               :
               :*/
               :
               :#include "structures.h"
               :
               :/************/
               :
               :int gord( float position , float grid_span , int grid_size ) {
               :
               :  int ordinate ;
               :
               :  float one_span = grid_span / (float)grid_size ;
               :
               :  ordinate = (int)( position / one_span ) + ( grid_size / 2 ) ;
               :
               :  if( position < 0 ) ordinate -= 1 ;
               :
               :  return ordinate ;
               :
               :}
               :
               :/************/
               :
               :float pythagoras( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { /* pythagoras total:      4 5.9e-04 */
               :
     1 1.5e-04 :  return sqrt( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) + ( ( z1 - z2 ) * ( z1 - z2 ) ) ) ;
               :
     3 4.4e-04 :}
/* 
 * Total samples for file : "/home2/users/alumnes/1125822/dades/linux/PCA/ProjecteFinal/finalProject1213q2/sources/3D_Dock/progs/manipulate_structures.c"
 * 
 *      3 4.4e-04
 */


               :/*
               :This file is part of ftdock, a program for rigid-body protein-protein docking 
               :Copyright (C) 1997-2000 Gidon Moont
               :
               :Biomolecular Modelling Laboratory
               :Imperial Cancer Research Fund
               :44 Lincoln's Inn Fields
               :London WC2A 3PX
               :
               :+44 (0)20 7269 3348
               :http://www.bmm.icnet.uk/
               :
               :This program is free software; you can redistribute it and/or
               :modify it under the terms of the GNU General Public License
               :as published by the Free Software Foundation; either version 2
               :of the License, or (at your option) any later version.
               :
               :This program is distributed in the hope that it will be useful,
               :but WITHOUT ANY WARRANTY; without even the implied warranty of
               :MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :GNU General Public License for more details.
               :
               :You should have received a copy of the GNU General Public License
               :along with this program; if not, write to the Free Software
               :Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
               :
               :*/
               :
               :#include "structures.h"
               :
               :struct Structure read_pdb_to_structure( char *pdb_file_name ) {
               :
               :/************/
               :
               :  /* Variables */
               :
               :  /* Counters */
               :  int	n_residues ;	/* number of residues */
               :  int	res_size ;	/* number of atoms in single residue */
               :
               :  /* File stuff */
               :  FILE	*pdb_file ;
               :  char	line_buffer[100] ;
               :
               :  /* What the data is going into */
               :  struct Structure		This_Structure ;
               :
               :  /* Variables from the PDB file */
               :  int	serial ;
               :  char		atom_name[5] ;
               :  char		res_name[4] ;
               :  char		chainID[2] ;
               :  char		res_seq_plus_iCode[6] ;
               :  float		coord_x , coord_y , coord_z ;
               :  float		occupancy, temp_factor ;
               :  char		olc[2] ;
               :  int		nc ;
               :
               :  /* Comparison values */
               :  char	present_res_seq_plus_iCode[6] ;
               :
               :/************/
               :
               :  setvbuf( stdout , (char *)NULL , _IONBF , 0 ) ;
               :
               :  /* File handling */
               :
               :  /* Open file */
               :  printf( "  reading parsed pdb file: %s\n", pdb_file_name ) ;
               :  if( ( pdb_file = fopen( pdb_file_name, "r" ) ) == NULL ) {
               :    printf( "This file does not exist here, or is unreadable.\nDying\n\n" ) ;
               :    exit( EXIT_FAILURE ) ;
               :  }
               :
               :/************/
               :
               :  /* Initialisations */
               :
               :  /* Counters */
               :  n_residues = 0 ;
               :  res_size = 0 ;
               :
               :  /* Comparison values */
               :  strcpy( present_res_seq_plus_iCode , ">" ) ;
               :
               :  /* Memory allocation */
               :  if( ( This_Structure.Residue = ( struct Amino_Acid * ) malloc ( sizeof_Amino_Acid ) ) == NULL ) {
               :    GENERAL_MEMORY_PROBLEM
               :  }
               :
               :/************/
               :
               :  /* Read PDB file */
               :
               :  /* The Atoms */
               :
               :  while( fgets( line_buffer, 85, pdb_file ) ) {
               :
               :    if( strncmp( line_buffer, "ATOM", 4 ) == 0 ) {
               :
               :      /* Have an ATOM */
               :
               :      /* Get Values */
               :
               :      /* the following may seem silly, but sscanf convention means that two
               :         float fields with no white space between them, where the first is
               :         less than the maximum field width, mucks up everything.
               :      */
               :
               :      sscanf( line_buffer +  6 , "%5d" , &serial ) ;
               :      sscanf( line_buffer + 30 , "%8f" , &coord_x ) ;
               :      sscanf( line_buffer + 38 , "%8f" , &coord_y ) ;
               :      sscanf( line_buffer + 46 , "%8f" , &coord_z ) ;
               :      sscanf( line_buffer + 54 , "%6f" , &occupancy ) ;
               :      sscanf( line_buffer + 60 , "%6f" , &temp_factor ) ;
               :      sscanf( line_buffer + 82 , "%2d" , &nc ) ;
               :
               :      strncpy( atom_name,		line_buffer+12,	4 ) ;
               :      strncpy( res_name,		line_buffer+17,	3 ) ;
               :      strncpy( chainID,			line_buffer+21,	1 ) ;
               :      strncpy( res_seq_plus_iCode,	line_buffer+22,	5 ) ;
               :      strncpy( olc,			line_buffer+80,	1 ) ;
               :
               :      strncpy( atom_name + 4,		"\0", 1 ) ;
               :      strncpy( res_name + 3,		"\0", 1 ) ;
               :      strncpy( chainID + 1,		"\0", 1 ) ;
               :      strncpy( res_seq_plus_iCode + 5,	"\0", 1 ) ;
               :      strncpy( olc + 1,			"\0", 1 ) ;
               :
               :/************/
               :
               :      /* New Residue */
               :
               :      if( strcmp( res_seq_plus_iCode , present_res_seq_plus_iCode ) != 0 ) {
               :
               :        /* have next residue */
               :
               :        /* Store old info */
               :        This_Structure.Residue[n_residues].size = res_size ;
               :
               :        /* Increment, Reset numbers */
               :        n_residues ++ ;
               :        res_size = 0 ;
               :
               :        /* Memory management */
               :        if( ( This_Structure.Residue = (struct Amino_Acid * ) realloc ( This_Structure.Residue, ( n_residues + 1 ) * sizeof_Amino_Acid ) ) == NULL ) {
               :          GENERAL_MEMORY_PROBLEM
               :        }
               :        if( ( This_Structure.Residue[n_residues].Atom = ( struct Atom * ) malloc ( sizeof_Atom ) ) == NULL ) {
               :          GENERAL_MEMORY_PROBLEM
               :        }
               :
               :        /* Store new info */
               :        strcpy( This_Structure.Residue[n_residues].res_seq_plus_iCode , res_seq_plus_iCode );
               :        strcpy( This_Structure.Residue[n_residues].res_name ,           res_name ) ;
               :        strcpy( This_Structure.Residue[n_residues].chainID ,            chainID ) ;
               :        strcpy( This_Structure.Residue[n_residues].olc,                 olc ) ;
               :        This_Structure.Residue[n_residues].nc = nc ;
               :
               :      }
               :
               :      strcpy( present_res_seq_plus_iCode , res_seq_plus_iCode ) ;
               :
               :/************/
               :
               :      /* Put Atoms into Structure */
               :
               :      res_size ++ ;
               :
               :      if( ( This_Structure.Residue[n_residues].Atom = ( struct Atom * ) realloc ( This_Structure.Residue[n_residues].Atom, ( res_size + 1 ) * sizeof_Atom ) ) == NULL ) {
               :        GENERAL_MEMORY_PROBLEM
               :      }
               :
               :      This_Structure.Residue[n_residues].Atom[res_size].serial = serial ;
               :      strcpy( This_Structure.Residue[n_residues].Atom[res_size].atom_name, atom_name ) ;
               :      This_Structure.Residue[n_residues].Atom[res_size].coord[1] = coord_x ;
               :      This_Structure.Residue[n_residues].Atom[res_size].coord[2] = coord_y ;
               :      This_Structure.Residue[n_residues].Atom[res_size].coord[3] = coord_z ;
               :      This_Structure.Residue[n_residues].Atom[res_size].occupancy = occupancy ;
               :      This_Structure.Residue[n_residues].Atom[res_size].temp_factor = temp_factor ;
               :
               :/************/
               :
               :    }
               :
               :  } /* got to end of pdb file */
               :
               :/************/
               :
               :  /* Clean up */
               :
               :  This_Structure.Residue[n_residues].size = res_size ;
               :  This_Structure.length = n_residues ;
               :  strcpy( This_Structure.ident , pdb_file_name  );
               :
               :  /* Finish off */
               :
               :  fclose( pdb_file ) ;
               :
               :  return This_Structure ;
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :void write_structure_to_pdb( struct Structure This_Structure , char *pdb_file_name ) {
               :
               :/************/
               :
               :  /* Variables */
               :
               :  /* Counters */
               :  int	residue , atom ;
               :
               :  /* File stuff */
               :  FILE		*pdb_file ;
               :
               :/************/
               :
               :  /* File handling */
               :
               :  /* Open file */
               :  printf( "Writing file: %s\n", pdb_file_name ) ;
               :  if( ( pdb_file = fopen( pdb_file_name, "w" ) ) == NULL ) {
               :    printf( "This file could not be opened.\nDying\n\n" ) ;
               :    exit(  EXIT_FAILURE ) ;
               :  }
               :
               :/************/
               :
               :  /* Write PDB file */
               :
               :  for( residue = 1 ; residue <= This_Structure.length ; residue ++ ) {
               :
               :    for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      fprintf( pdb_file, "ATOM  %5d %4s %3s %1s%5s   %8.3f%8.3f%8.3f%6.2f%6.2f              %1s %2d\n", This_Structure.Residue[residue].Atom[atom].serial, This_Structure.Residue[residue].Atom[atom].atom_name, This_Structure.Residue[residue].res_name, This_Structure.Residue[residue].chainID, This_Structure.Residue[residue].res_seq_plus_iCode, This_Structure.Residue[residue].Atom[atom].coord[1], This_Structure.Residue[residue].Atom[atom].coord[2], This_Structure.Residue[residue].Atom[atom].coord[3], This_Structure.Residue[residue].Atom[atom].occupancy, This_Structure.Residue[residue].Atom[atom].temp_factor, This_Structure.Residue[residue].olc, This_Structure.Residue[residue].nc ) ;
               :
               :    }
               :
               :  }
               :
               :/************/
               :
               :  /* Finish off */
               :
               :  fclose( pdb_file ) ;
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :struct Structure duplicate_structure( struct Structure This_Structure ) { /* duplicate_structure total:      2 2.9e-04 */
               :
               :/************/
               :
               :  /* Variables */
               :  struct Structure	New_Structure ;
               :
               :  /* Counters */
               :  int		residue , atom ;
               :
               :/************/
               :
               :  if( ( New_Structure.Residue = ( struct Amino_Acid * ) malloc ( ( This_Structure.length + 1 ) * sizeof_Amino_Acid ) ) == NULL ) {
               :    GENERAL_MEMORY_PROBLEM
               :  }
               :
               :  strcpy( New_Structure.ident , This_Structure.ident ) ;
               :  New_Structure.length = This_Structure.length ;
               :
               :  for( residue = 1 ; residue <= This_Structure.length ; residue ++ ) {
               :
               :    New_Structure.Residue[residue] = This_Structure.Residue[residue] ;
               :
               :    if( ( New_Structure.Residue[residue].Atom = ( struct Atom * ) malloc ( ( This_Structure.Residue[residue].size + 1 ) * sizeof_Atom ) ) == NULL ) {
               :      GENERAL_MEMORY_PROBLEM
               :    }
               :
     1 1.5e-04 :    for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom ++ ) {
               :
     1 1.5e-04 :      New_Structure.Residue[residue].Atom[atom] = This_Structure.Residue[residue].Atom[atom] ;
               :
               :    }
               :
               :  }
               :
               :  return New_Structure ;
               :
               :/************/
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :struct Structure translate_structure( struct Structure This_Structure , float x_shift , float y_shift , float z_shift ) {
               :
               :/************/
               :
               :  /* Variables */
               :  struct Structure	New_Structure ;
               :
               :  /* Counters */
               :  int		residue , atom ;
               :
               :/************/
               :
               :  New_Structure = duplicate_structure( This_Structure ) ;
               :
               :/************/
               :
               :  for( residue = 1 ; residue <= New_Structure.length ; residue ++ ) {
               :
               :    for( atom = 1 ; atom <= New_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      New_Structure.Residue[residue].Atom[atom].coord[1] += x_shift ;
               :      New_Structure.Residue[residue].Atom[atom].coord[2] += y_shift ;
               :      New_Structure.Residue[residue].Atom[atom].coord[3] += z_shift ;
               :
               :    }
               :
               :  }
               :
               :  return New_Structure ;
               :
               :/************/
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :struct Structure translate_structure_onto_origin( struct Structure This_Structure ) {
               :
               :/************/
               :
               :  /* Variables */
               :  struct Structure	New_Structure ;
               :
               :  float			average_x , average_y , average_z ;
               :
               :  /* Counters */
               :  int		residue , atom , total_atoms ;
               :
               :/************/
               :
               :  New_Structure = duplicate_structure( This_Structure ) ;
               :
               :/************/
               :
               :  /* Find current centre */
               :
               :  total_atoms = 0 ;
               :
               :  average_x = 0 ;
               :  average_y = 0 ;
               :  average_z = 0 ;
               :
               :  for( residue = 1 ; residue <= New_Structure.length ; residue ++ ) {
               :
               :    for( atom = 1 ; atom <= New_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      total_atoms ++ ;
               :
               :      average_x += New_Structure.Residue[residue].Atom[atom].coord[1] ;
               :      average_y += New_Structure.Residue[residue].Atom[atom].coord[2] ;
               :      average_z += New_Structure.Residue[residue].Atom[atom].coord[3] ;
               :
               :    }
               :
               :  }
               :
               :  average_x = average_x / (float)total_atoms ;
               :  average_y = average_y / (float)total_atoms ;
               :  average_z = average_z / (float)total_atoms ;
               :
               :/************/
               :
               :  /* Translate */
               :
               :  for( residue = 1 ; residue <= New_Structure.length ; residue ++ ) {
               :
               :    for( atom = 1 ; atom <= New_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      New_Structure.Residue[residue].Atom[atom].coord[1] -= average_x ;
               :      New_Structure.Residue[residue].Atom[atom].coord[2] -= average_y ;
               :      New_Structure.Residue[residue].Atom[atom].coord[3] -= average_z ;
               :
               :    }
               :
               :  }
               :
               :  return New_Structure ;
               :
               :/************/
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :struct Structure rotate_structure( struct Structure This_Structure , int z_twist , int theta , int phi ) {
               :
               :/************/
               :
               :  /* Variables */
               :  struct Structure	New_Structure ;
               :
               :  float			post_z_twist_x , post_z_twist_y , post_z_twist_z ;
               :  float			post_theta_x , post_theta_y , post_theta_z ;
               :
               :  /* Counters */
               :  int		residue , atom ;
               :
               :/************/
               :
               :  New_Structure = duplicate_structure( This_Structure ) ;
               :
               :/************/
               :
               :  for( residue = 1 ; residue <= New_Structure.length ; residue ++ ) {
               :
               :    for( atom = 1 ; atom <= New_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      /* Perform Z axis twist */
               :      post_z_twist_x = New_Structure.Residue[residue].Atom[atom].coord[1] * cos( 0.017453293 * z_twist ) - New_Structure.Residue[residue].Atom[atom].coord[2] * sin( 0.017453293 * z_twist ) ;
               :      post_z_twist_y = New_Structure.Residue[residue].Atom[atom].coord[1] * sin( 0.017453293 * z_twist ) + New_Structure.Residue[residue].Atom[atom].coord[2] * cos( 0.017453293 * z_twist ) ;
               :      post_z_twist_z = New_Structure.Residue[residue].Atom[atom].coord[3] ;
               :
               :      /* Perform theta twist along plane of x-z */
               :      post_theta_x = post_z_twist_z * sin( 0.017453293 * theta ) + post_z_twist_x * cos( 0.017453293 * theta ) ; 
               :      post_theta_y = post_z_twist_y ;
               :      post_theta_z = post_z_twist_z * cos( 0.017453293 * theta ) - post_z_twist_x * sin( 0.017453293 * theta ) ; 
               :
               :      /* Perform phi twist around z axis */
               :      New_Structure.Residue[residue].Atom[atom].coord[1] = post_theta_x * cos( 0.017453293 * phi ) - post_theta_y * sin( 0.017453293 * phi ) ;
               :      New_Structure.Residue[residue].Atom[atom].coord[2] = post_theta_x * sin( 0.017453293 * phi ) + post_theta_y * cos( 0.017453293 * phi ) ;
               :      New_Structure.Residue[residue].Atom[atom].coord[3] = post_theta_z ;
               :
               :    }
               :
               :  }
               :
               :  return New_Structure ;
               :
               :/************/
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :struct Structure merge_structures( struct Structure Structure_One , struct Structure Structure_Two ) {
               :
               :/************/
               :
               :  /* Variables */
               :  struct Structure	New_Structure ;
               :
               :  /* Counters */
               :  int		residue , atom , new_residue ;
               :
               :/************/
               :
               :  if( ( New_Structure.Residue = ( struct Amino_Acid * ) malloc ( ( Structure_One.length + Structure_Two.length + 1 ) * sizeof_Amino_Acid ) ) == NULL ) {
               :    GENERAL_MEMORY_PROBLEM
               :  }
               :
               :  strcpy( New_Structure.ident , "Complex" ) ;
               :  New_Structure.length = Structure_One.length + Structure_Two.length ;
               :
               :  for( residue = 1 ; residue <= Structure_One.length ; residue ++ ) {
               :
               :    if( ( New_Structure.Residue[residue].Atom = ( struct Atom * ) malloc ( ( Structure_One.Residue[residue].size + 1 ) * sizeof_Atom ) ) == NULL ) {
               :      GENERAL_MEMORY_PROBLEM
               :    }
               :    strcpy( New_Structure.Residue[residue].res_name           , Structure_One.Residue[residue].res_name ) ;
               :    strcpy( New_Structure.Residue[residue].chainID            , Structure_One.Residue[residue].chainID ) ;
               :    strcpy( New_Structure.Residue[residue].res_seq_plus_iCode , Structure_One.Residue[residue].res_seq_plus_iCode ) ;
               :    strcpy( New_Structure.Residue[residue].olc                , Structure_One.Residue[residue].olc ) ;
               :    New_Structure.Residue[residue].nc                         = Structure_One.Residue[residue].nc   ;
               :    New_Structure.Residue[residue].size                       = Structure_One.Residue[residue].size ;
               :
               :    if( ( New_Structure.Residue[residue].Atom = ( struct Atom * ) malloc ( ( Structure_One.Residue[residue].size + 1 ) * sizeof_Atom ) ) == NULL ) {
               :      GENERAL_MEMORY_PROBLEM
               :    }
               :
               :    for( atom = 1 ; atom <= Structure_One.Residue[residue].size ; atom ++ ) {
               :
               :      New_Structure.Residue[residue].Atom[atom] = Structure_One.Residue[residue].Atom[atom] ;
               :
               :    }
               :
               :  }
               :
               :  for( residue = 1 ; residue <= Structure_Two.length ; residue ++ ) {
               :
               :    new_residue = residue + Structure_One.length ;
               :
               :    strcpy( New_Structure.Residue[new_residue].chainID            , Structure_Two.Residue[residue].chainID ) ;
               :    strcpy( New_Structure.Residue[new_residue].res_seq_plus_iCode , Structure_Two.Residue[residue].res_seq_plus_iCode ) ;
               :    strcpy( New_Structure.Residue[new_residue].olc                , Structure_Two.Residue[residue].olc ) ;
               :    New_Structure.Residue[new_residue].nc                         = Structure_Two.Residue[residue].nc   ;
               :    New_Structure.Residue[new_residue].size                       = Structure_Two.Residue[residue].size ;
               :    strcpy( New_Structure.Residue[new_residue].res_name           , Structure_Two.Residue[residue].res_name ) ;
               :
               :    if( ( New_Structure.Residue[new_residue].Atom = ( struct Atom * ) malloc ( ( Structure_Two.Residue[residue].size + 1 ) * sizeof_Atom ) ) == NULL ) {
               :      GENERAL_MEMORY_PROBLEM
               :    }
               :    for( atom = 1 ; atom <= Structure_Two.Residue[residue].size ; atom ++ ) {
               :
               :      New_Structure.Residue[new_residue].Atom[atom] = Structure_Two.Residue[residue].Atom[atom] ;
               :
               :    }
               :
               :  }
               :
               :  return New_Structure ;
               :
               :/************/
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :float radius_of_structure( struct Structure This_Structure ) { /* radius_of_structure total:      1 1.5e-04 */
               :
               :/************/
               :
               :  /* Variables */
               :  float		present , largest ;
               :
               :  /* Counters */
               :  int	residue , atom ;
               :
               :/************/
               :
               :  largest = 0 ;
               :
     1 1.5e-04 :  for( residue = 1 ; residue <= This_Structure.length ; residue ++ ) {
               :
               :    for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom ++ ) {
               :
               :      present = This_Structure.Residue[residue].Atom[atom].coord[1] * This_Structure.Residue[residue].Atom[atom].coord[1] + This_Structure.Residue[residue].Atom[atom].coord[2] * This_Structure.Residue[residue].Atom[atom].coord[2] + This_Structure.Residue[residue].Atom[atom].coord[3] * This_Structure.Residue[residue].Atom[atom].coord[3] ;
               :
               :      if( present > largest ) largest = present ;
               :
               :    }
               :
               :  }
               :
               :  return sqrt( largest ) ;
               :
               :/************/
               :
               :}
               :
               :
               :
               :/************************/
               :
               :
               :
               :float total_span_of_structures( struct Structure Structure_1 , struct Structure Structure_2 ) {
               :
               :  return  1 + ( ( radius_of_structure( Structure_1 ) + radius_of_structure( Structure_2 ) ) * 2 ) ;
               :
               :}
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/string/../sysdeps/i386/memchr.S"
 * 
 *      2 2.9e-04
 */


 /* memchr total:      2 2.9e-04 */
/* 
 * Total samples for file : "/home/abuild/rpmbuild/BUILD/glibc-2.14.1/stdio-common/vfprintf.c"
 * 
 *      1 1.5e-04
 */


 /* vfprintf total:      1 1.5e-04 */
